// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/ast.d.ts
declare module '~@angular/compiler/src/expression_parser/ast' {
export class ParserError {
    input: string;
    errLocation: string;
    ctxLocation: any;
    message: string;
    constructor(message: string, input: string, errLocation: string, ctxLocation?: any);
}
export class ParseSpan {
    start: number;
    end: number;
    constructor(start: number, end: number);
}
export class AST {
    span: ParseSpan;
    constructor(span: ParseSpan);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
/**
 * Represents a quoted expression of the form:
 *
 * quote = prefix `:` uninterpretedExpression
 * prefix = identifier
 * uninterpretedExpression = arbitrary string
 *
 * A quoted expression is meant to be pre-processed by an AST transformer that
 * converts it into another AST that no longer contains quoted expressions.
 * It is meant to allow third-party developers to extend Angular template
 * expression language. The `uninterpretedExpression` part of the quote is
 * therefore not interpreted by the Angular's own expression parser.
 */
export class Quote extends AST {
    prefix: string;
    uninterpretedExpression: string;
    location: any;
    constructor(span: ParseSpan, prefix: string, uninterpretedExpression: string, location: any);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
export class EmptyExpr extends AST {
    visit(visitor: AstVisitor, context?: any): void;
}
export class ImplicitReceiver extends AST {
    visit(visitor: AstVisitor, context?: any): any;
}
/**
 * Multiple expressions separated by a semicolon.
 */
export class Chain extends AST {
    expressions: any[];
    constructor(span: ParseSpan, expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Conditional extends AST {
    condition: AST;
    trueExp: AST;
    falseExp: AST;
    constructor(span: ParseSpan, condition: AST, trueExp: AST, falseExp: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PropertyRead extends AST {
    receiver: AST;
    name: string;
    constructor(span: ParseSpan, receiver: AST, name: string);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PropertyWrite extends AST {
    receiver: AST;
    name: string;
    value: AST;
    constructor(span: ParseSpan, receiver: AST, name: string, value: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class SafePropertyRead extends AST {
    receiver: AST;
    name: string;
    constructor(span: ParseSpan, receiver: AST, name: string);
    visit(visitor: AstVisitor, context?: any): any;
}
export class KeyedRead extends AST {
    obj: AST;
    key: AST;
    constructor(span: ParseSpan, obj: AST, key: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class KeyedWrite extends AST {
    obj: AST;
    key: AST;
    value: AST;
    constructor(span: ParseSpan, obj: AST, key: AST, value: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class BindingPipe extends AST {
    exp: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, exp: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralPrimitive extends AST {
    value: any;
    constructor(span: ParseSpan, value: any);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralArray extends AST {
    expressions: any[];
    constructor(span: ParseSpan, expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralMap extends AST {
    keys: any[];
    values: any[];
    constructor(span: ParseSpan, keys: any[], values: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Interpolation extends AST {
    strings: any[];
    expressions: any[];
    constructor(span: ParseSpan, strings: any[], expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Binary extends AST {
    operation: string;
    left: AST;
    right: AST;
    constructor(span: ParseSpan, operation: string, left: AST, right: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PrefixNot extends AST {
    expression: AST;
    constructor(span: ParseSpan, expression: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class MethodCall extends AST {
    receiver: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, receiver: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class SafeMethodCall extends AST {
    receiver: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, receiver: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class FunctionCall extends AST {
    target: AST;
    args: any[];
    constructor(span: ParseSpan, target: AST, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class ASTWithSource extends AST {
    ast: AST;
    source: string;
    location: string;
    errors: ParserError[];
    constructor(ast: AST, source: string, location: string, errors: ParserError[]);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
export class TemplateBinding {
    key: string;
    keyIsVar: boolean;
    name: string;
    expression: ASTWithSource;
    constructor(key: string, keyIsVar: boolean, name: string, expression: ASTWithSource);
}
export interface AstVisitor {
    visitBinary(ast: Binary, context: any): any;
    visitChain(ast: Chain, context: any): any;
    visitConditional(ast: Conditional, context: any): any;
    visitFunctionCall(ast: FunctionCall, context: any): any;
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;
    visitInterpolation(ast: Interpolation, context: any): any;
    visitKeyedRead(ast: KeyedRead, context: any): any;
    visitKeyedWrite(ast: KeyedWrite, context: any): any;
    visitLiteralArray(ast: LiteralArray, context: any): any;
    visitLiteralMap(ast: LiteralMap, context: any): any;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;
    visitMethodCall(ast: MethodCall, context: any): any;
    visitPipe(ast: BindingPipe, context: any): any;
    visitPrefixNot(ast: PrefixNot, context: any): any;
    visitPropertyRead(ast: PropertyRead, context: any): any;
    visitPropertyWrite(ast: PropertyWrite, context: any): any;
    visitQuote(ast: Quote, context: any): any;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;
}
export class RecursiveAstVisitor implements AstVisitor {
    visitBinary(ast: Binary, context: any): any;
    visitChain(ast: Chain, context: any): any;
    visitConditional(ast: Conditional, context: any): any;
    visitPipe(ast: BindingPipe, context: any): any;
    visitFunctionCall(ast: FunctionCall, context: any): any;
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;
    visitInterpolation(ast: Interpolation, context: any): any;
    visitKeyedRead(ast: KeyedRead, context: any): any;
    visitKeyedWrite(ast: KeyedWrite, context: any): any;
    visitLiteralArray(ast: LiteralArray, context: any): any;
    visitLiteralMap(ast: LiteralMap, context: any): any;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;
    visitMethodCall(ast: MethodCall, context: any): any;
    visitPrefixNot(ast: PrefixNot, context: any): any;
    visitPropertyRead(ast: PropertyRead, context: any): any;
    visitPropertyWrite(ast: PropertyWrite, context: any): any;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;
    visitAll(asts: AST[], context: any): any;
    visitQuote(ast: Quote, context: any): any;
}
export class AstTransformer implements AstVisitor {
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST;
    visitInterpolation(ast: Interpolation, context: any): AST;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST;
    visitPropertyRead(ast: PropertyRead, context: any): AST;
    visitPropertyWrite(ast: PropertyWrite, context: any): AST;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST;
    visitMethodCall(ast: MethodCall, context: any): AST;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST;
    visitFunctionCall(ast: FunctionCall, context: any): AST;
    visitLiteralArray(ast: LiteralArray, context: any): AST;
    visitLiteralMap(ast: LiteralMap, context: any): AST;
    visitBinary(ast: Binary, context: any): AST;
    visitPrefixNot(ast: PrefixNot, context: any): AST;
    visitConditional(ast: Conditional, context: any): AST;
    visitPipe(ast: BindingPipe, context: any): AST;
    visitKeyedRead(ast: KeyedRead, context: any): AST;
    visitKeyedWrite(ast: KeyedWrite, context: any): AST;
    visitAll(asts: any[]): any[];
    visitChain(ast: Chain, context: any): AST;
    visitQuote(ast: Quote, context: any): AST;
}
}
declare module '@angular/compiler/src/expression_parser/ast' {
export * from '~@angular/compiler/src/expression_parser/ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/template_parser/template_ast.d.ts
declare module '~@angular/compiler/src/template_parser/template_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SecurityContext } from '@angular/core';
import { CompileDirectiveMetadata, CompileProviderMetadata, CompileTokenMetadata } from '~@angular/compiler/src/compile_metadata';
import { AST } from '~@angular/compiler/src/expression_parser/ast';
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import { LifecycleHooks } from '~@angular/compiler/src/private_import_core';
/**
 * An Abstract Syntax Tree node representing part of a parsed Angular template.
 */
export interface TemplateAst {
    /**
     * The source span from which this node was parsed.
     */
    sourceSpan: ParseSourceSpan;
    /**
     * Visit this node and possibly transform it.
     */
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A segment of text within the template.
 */
export class TextAst implements TemplateAst {
    value: string;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A bound expression within the text of a template.
 */
export class BoundTextAst implements TemplateAst {
    value: AST;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(value: AST, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A plain attribute on an element.
 */
export class AttrAst implements TemplateAst {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
 * `[@trigger]="stateExp"`)
 */
export class BoundElementPropertyAst implements TemplateAst {
    name: string;
    type: PropertyBindingType;
    securityContext: SecurityContext;
    needsRuntimeSecurityContext: boolean;
    value: AST;
    unit: string;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, type: PropertyBindingType, securityContext: SecurityContext, needsRuntimeSecurityContext: boolean, value: AST, unit: string, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
    isAnimation: boolean;
}
/**
 * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
 * `(@trigger.phase)="callback($event)"`).
 */
export class BoundEventAst implements TemplateAst {
    name: string;
    target: string;
    phase: string;
    handler: AST;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, target: string, phase: string, handler: AST, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
    fullName: string;
    isAnimation: boolean;
}
/**
 * A reference declaration on an element (e.g. `let someName="expression"`).
 */
export class ReferenceAst implements TemplateAst {
    name: string;
    value: CompileTokenMetadata;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: CompileTokenMetadata, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A variable declaration on a <template> (e.g. `var-someName="someLocalName"`).
 */
export class VariableAst implements TemplateAst {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * An element declaration in a template.
 */
export class ElementAst implements TemplateAst {
    name: string;
    attrs: AttrAst[];
    inputs: BoundElementPropertyAst[];
    outputs: BoundEventAst[];
    references: ReferenceAst[];
    directives: DirectiveAst[];
    providers: ProviderAst[];
    hasViewContainer: boolean;
    children: TemplateAst[];
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    endSourceSpan: ParseSourceSpan;
    constructor(name: string, attrs: AttrAst[], inputs: BoundElementPropertyAst[], outputs: BoundEventAst[], references: ReferenceAst[], directives: DirectiveAst[], providers: ProviderAst[], hasViewContainer: boolean, children: TemplateAst[], ngContentIndex: number, sourceSpan: ParseSourceSpan, endSourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A `<template>` element included in an Angular template.
 */
export class EmbeddedTemplateAst implements TemplateAst {
    attrs: AttrAst[];
    outputs: BoundEventAst[];
    references: ReferenceAst[];
    variables: VariableAst[];
    directives: DirectiveAst[];
    providers: ProviderAst[];
    hasViewContainer: boolean;
    children: TemplateAst[];
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(attrs: AttrAst[], outputs: BoundEventAst[], references: ReferenceAst[], variables: VariableAst[], directives: DirectiveAst[], providers: ProviderAst[], hasViewContainer: boolean, children: TemplateAst[], ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A directive property with a bound value (e.g. `*ngIf="condition").
 */
export class BoundDirectivePropertyAst implements TemplateAst {
    directiveName: string;
    templateName: string;
    value: AST;
    sourceSpan: ParseSourceSpan;
    constructor(directiveName: string, templateName: string, value: AST, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A directive declared on an element.
 */
export class DirectiveAst implements TemplateAst {
    directive: CompileDirectiveMetadata;
    inputs: BoundDirectivePropertyAst[];
    hostProperties: BoundElementPropertyAst[];
    hostEvents: BoundEventAst[];
    sourceSpan: ParseSourceSpan;
    constructor(directive: CompileDirectiveMetadata, inputs: BoundDirectivePropertyAst[], hostProperties: BoundElementPropertyAst[], hostEvents: BoundEventAst[], sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A provider declared on an element
 */
export class ProviderAst implements TemplateAst {
    token: CompileTokenMetadata;
    multiProvider: boolean;
    eager: boolean;
    providers: CompileProviderMetadata[];
    providerType: ProviderAstType;
    lifecycleHooks: LifecycleHooks[];
    sourceSpan: ParseSourceSpan;
    constructor(token: CompileTokenMetadata, multiProvider: boolean, eager: boolean, providers: CompileProviderMetadata[], providerType: ProviderAstType, lifecycleHooks: LifecycleHooks[], sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
export enum ProviderAstType {
    PublicService = 0,
    PrivateService = 1,
    Component = 2,
    Directive = 3,
    Builtin = 4,
}
/**
 * Position where content is to be projected (instance of `<ng-content>` in a template).
 */
export class NgContentAst implements TemplateAst {
    index: number;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(index: number, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * Enumeration of types of property bindings.
 */
export enum PropertyBindingType {
    /**
     * A normal binding to a property (e.g. `[property]="expression"`).
     */
    Property = 0,
    /**
     * A binding to an element attribute (e.g. `[attr.name]="expression"`).
     */
    Attribute = 1,
    /**
     * A binding to a CSS class (e.g. `[class.name]="condition"`).
     */
    Class = 2,
    /**
     * A binding to a style rule (e.g. `[style.rule]="expression"`).
     */
    Style = 3,
    /**
     * A binding to an animation reference (e.g. `[animate.key]="expression"`).
     */
    Animation = 4,
}
/**
 * A visitor for {@link TemplateAst} trees that will process each node.
 */
export interface TemplateAstVisitor {
    visit?(ast: TemplateAst, context: any): any;
    visitNgContent(ast: NgContentAst, context: any): any;
    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any;
    visitElement(ast: ElementAst, context: any): any;
    visitReference(ast: ReferenceAst, context: any): any;
    visitVariable(ast: VariableAst, context: any): any;
    visitEvent(ast: BoundEventAst, context: any): any;
    visitElementProperty(ast: BoundElementPropertyAst, context: any): any;
    visitAttr(ast: AttrAst, context: any): any;
    visitBoundText(ast: BoundTextAst, context: any): any;
    visitText(ast: TextAst, context: any): any;
    visitDirective(ast: DirectiveAst, context: any): any;
    visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any;
}
/**
 * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
 */
export function templateVisitAll(visitor: TemplateAstVisitor, asts: TemplateAst[], context?: any): any[];
}
declare module '@angular/compiler/src/template_parser/template_ast' {
export * from '~@angular/compiler/src/template_parser/template_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/i18n_html_parser.d.ts
declare module '~@angular/compiler/src/i18n/i18n_html_parser' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseTreeResult } from '~@angular/compiler/src/ml_parser/parser';
export class I18NHtmlParser implements HtmlParser {
    private _htmlParser;
    private _translations;
    private _translationsFormat;
    getTagDefinition: any;
    constructor(_htmlParser: HtmlParser, _translations?: string, _translationsFormat?: string);
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
    private _createSerializer(interpolationConfig);
}
}
declare module '@angular/compiler/src/i18n/i18n_html_parser' {
export * from '~@angular/compiler/src/i18n/i18n_html_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/private_import_core.d.ts
declare module '~@angular/compiler/src/private_import_core' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __core_private__ as r } from '@angular/core';
export const isDefaultChangeDetectionStrategy: typeof r.isDefaultChangeDetectionStrategy;
export type ChangeDetectorStatus = typeof r._ChangeDetectorStatus;
export const ChangeDetectorStatus: typeof r.ChangeDetectorStatus;
export type LifecycleHooks = typeof r._LifecycleHooks;
export const LifecycleHooks: typeof r.LifecycleHooks;
export const LIFECYCLE_HOOKS_VALUES: typeof r.LIFECYCLE_HOOKS_VALUES;
export type ReflectorReader = typeof r._ReflectorReader;
export const ReflectorReader: typeof r.ReflectorReader;
export type AppElement = typeof r._AppElement;
export const AppElement: typeof r.AppElement;
export const CodegenComponentFactoryResolver: typeof r.CodegenComponentFactoryResolver;
export const AppView: typeof r.AppView;
export const DebugAppView: typeof r.DebugAppView;
export const NgModuleInjector: typeof r.NgModuleInjector;
export const registerModuleFactory: typeof r.registerModuleFactory;
export type ViewType = typeof r._ViewType;
export const ViewType: typeof r.ViewType;
export const view_utils: typeof r.view_utils;
export const DebugContext: typeof r.DebugContext;
export const StaticNodeDebugInfo: typeof r.StaticNodeDebugInfo;
export const devModeEqual: typeof r.devModeEqual;
export const UNINITIALIZED: typeof r.UNINITIALIZED;
export const ValueUnwrapper: typeof r.ValueUnwrapper;
export const TemplateRef_: typeof r.TemplateRef_;
export type RenderDebugInfo = typeof r._RenderDebugInfo;
export const RenderDebugInfo: typeof r.RenderDebugInfo;
export type Console = typeof r._Console;
export const Console: typeof r.Console;
export const reflector: typeof r.reflector;
export const Reflector: typeof r.Reflector;
export type Reflector = typeof r._Reflector;
export type ReflectionCapabilities = typeof r._ReflectionCapabilities;
export const ReflectionCapabilities: typeof r.ReflectionCapabilities;
export type NoOpAnimationPlayer = typeof r._NoOpAnimationPlayer;
export const NoOpAnimationPlayer: typeof r.NoOpAnimationPlayer;
export type AnimationPlayer = typeof r._AnimationPlayer;
export const AnimationPlayer: typeof r.AnimationPlayer;
export type AnimationSequencePlayer = typeof r._AnimationSequencePlayer;
export const AnimationSequencePlayer: typeof r.AnimationSequencePlayer;
export type AnimationGroupPlayer = typeof r._AnimationGroupPlayer;
export const AnimationGroupPlayer: typeof r.AnimationGroupPlayer;
export type AnimationKeyframe = typeof r._AnimationKeyframe;
export const AnimationKeyframe: typeof r.AnimationKeyframe;
export type AnimationStyles = typeof r._AnimationStyles;
export const AnimationStyles: typeof r.AnimationStyles;
export const ANY_STATE: string;
export const DEFAULT_STATE: string;
export const EMPTY_STATE: string;
export const FILL_STYLE_FLAG: string;
export const prepareFinalAnimationStyles: typeof r.prepareFinalAnimationStyles;
export const balanceAnimationKeyframes: typeof r.balanceAnimationKeyframes;
export const clearStyles: typeof r.clearStyles;
export const collectAndResolveStyles: typeof r.collectAndResolveStyles;
export const renderStyles: typeof r.renderStyles;
export type ViewMetadata = typeof r._ViewMetadata;
export const ViewMetadata: typeof r.ViewMetadata;
export type ComponentStillLoadingError = typeof r._ComponentStillLoadingError;
export const ComponentStillLoadingError: typeof r.ComponentStillLoadingError;
export const AnimationTransition: typeof r.AnimationTransition;
}
declare module '@angular/compiler/src/private_import_core' {
export * from '~@angular/compiler/src/private_import_core';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/template_parser/template_parser.d.ts
declare module '~@angular/compiler/src/template_parser/template_parser' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { OpaqueToken, SchemaMetadata } from '@angular/core';
import { CompileDirectiveMetadata, CompilePipeMetadata } from '~@angular/compiler/src/compile_metadata';
import { Parser } from '~@angular/compiler/src/expression_parser/parser';
import { I18NHtmlParser } from '~@angular/compiler/src/i18n/i18n_html_parser';
import { ParseTreeResult } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseError, ParseErrorLevel, ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import { Console } from '~@angular/compiler/src/private_import_core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { TemplateAst, TemplateAstVisitor } from '~@angular/compiler/src/template_parser/template_ast';
/**
 * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
 * parsed templates before compilation is invoked, allowing custom expression syntax
 * and other advanced transformations.
 *
 * This is currently an internal-only feature and not meant for general use.
 */
export const TEMPLATE_TRANSFORMS: OpaqueToken;
export class TemplateParseError extends ParseError {
    constructor(message: string, span: ParseSourceSpan, level: ParseErrorLevel);
}
export class TemplateParseResult {
    templateAst: TemplateAst[];
    errors: ParseError[];
    constructor(templateAst?: TemplateAst[], errors?: ParseError[]);
}
export class TemplateParser {
    private _exprParser;
    private _schemaRegistry;
    private _htmlParser;
    private _console;
    transforms: TemplateAstVisitor[];
    constructor(_exprParser: Parser, _schemaRegistry: ElementSchemaRegistry, _htmlParser: I18NHtmlParser, _console: Console, transforms: TemplateAstVisitor[]);
    parse(component: CompileDirectiveMetadata, template: string, directives: CompileDirectiveMetadata[], pipes: CompilePipeMetadata[], schemas: SchemaMetadata[], templateUrl: string): TemplateAst[];
    tryParse(component: CompileDirectiveMetadata, template: string, directives: CompileDirectiveMetadata[], pipes: CompilePipeMetadata[], schemas: SchemaMetadata[], templateUrl: string): TemplateParseResult;
    tryParseHtml(htmlAstWithErrors: ParseTreeResult, component: CompileDirectiveMetadata, template: string, directives: CompileDirectiveMetadata[], pipes: CompilePipeMetadata[], schemas: SchemaMetadata[], templateUrl: string): TemplateParseResult;
    expandHtml(htmlAstWithErrors: ParseTreeResult, forced?: boolean): ParseTreeResult;
    getInterpolationConfig(component: CompileDirectiveMetadata): InterpolationConfig;
}
export function splitClasses(classAttrValue: string): string[];
}
declare module '@angular/compiler/src/template_parser/template_parser' {
export * from '~@angular/compiler/src/template_parser/template_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/config.d.ts
declare module '~@angular/compiler/src/config' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ViewEncapsulation } from '@angular/core';
import { CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
export class CompilerConfig {
    renderTypes: RenderTypes;
    defaultEncapsulation: ViewEncapsulation;
    private _genDebugInfo;
    private _logBindingUpdate;
    useJit: boolean;
    constructor({renderTypes, defaultEncapsulation, genDebugInfo, logBindingUpdate, useJit}?: {
        renderTypes?: RenderTypes;
        defaultEncapsulation?: ViewEncapsulation;
        genDebugInfo?: boolean;
        logBindingUpdate?: boolean;
        useJit?: boolean;
    });
    genDebugInfo: boolean;
    logBindingUpdate: boolean;
}
/**
 * Types used for the renderer.
 * Can be replaced to specialize the generated output to a specific renderer
 * to help tree shaking.
 */
export abstract class RenderTypes {
    renderer: CompileIdentifierMetadata;
    renderText: CompileIdentifierMetadata;
    renderElement: CompileIdentifierMetadata;
    renderComment: CompileIdentifierMetadata;
    renderNode: CompileIdentifierMetadata;
    renderEvent: CompileIdentifierMetadata;
}
export class DefaultRenderTypes implements RenderTypes {
    renderer: CompileIdentifierMetadata;
    renderText: any;
    renderElement: any;
    renderComment: any;
    renderNode: any;
    renderEvent: any;
}
}
declare module '@angular/compiler/src/config' {
export * from '~@angular/compiler/src/config';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/compile_metadata.d.ts
declare module '~@angular/compiler/src/compile_metadata' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, SchemaMetadata, Type, ViewEncapsulation } from '@angular/core';
import { LifecycleHooks } from '~@angular/compiler/src/private_import_core';
export abstract class CompileMetadataWithIdentifier {
    identifier: CompileIdentifierMetadata;
}
export class CompileAnimationEntryMetadata {
    name: string;
    definitions: CompileAnimationStateMetadata[];
    constructor(name?: string, definitions?: CompileAnimationStateMetadata[]);
}
export abstract class CompileAnimationStateMetadata {
}
export class CompileAnimationStateDeclarationMetadata extends CompileAnimationStateMetadata {
    stateNameExpr: string;
    styles: CompileAnimationStyleMetadata;
    constructor(stateNameExpr: string, styles: CompileAnimationStyleMetadata);
}
export class CompileAnimationStateTransitionMetadata extends CompileAnimationStateMetadata {
    stateChangeExpr: string;
    steps: CompileAnimationMetadata;
    constructor(stateChangeExpr: string, steps: CompileAnimationMetadata);
}
export abstract class CompileAnimationMetadata {
}
export class CompileAnimationKeyframesSequenceMetadata extends CompileAnimationMetadata {
    steps: CompileAnimationStyleMetadata[];
    constructor(steps?: CompileAnimationStyleMetadata[]);
}
export class CompileAnimationStyleMetadata extends CompileAnimationMetadata {
    offset: number;
    styles: Array<string | {
        [key: string]: string | number;
    }>;
    constructor(offset: number, styles?: Array<string | {
        [key: string]: string | number;
    }>);
}
export class CompileAnimationAnimateMetadata extends CompileAnimationMetadata {
    timings: string | number;
    styles: CompileAnimationStyleMetadata | CompileAnimationKeyframesSequenceMetadata;
    constructor(timings?: string | number, styles?: CompileAnimationStyleMetadata | CompileAnimationKeyframesSequenceMetadata);
}
export abstract class CompileAnimationWithStepsMetadata extends CompileAnimationMetadata {
    steps: CompileAnimationMetadata[];
    constructor(steps?: CompileAnimationMetadata[]);
}
export class CompileAnimationSequenceMetadata extends CompileAnimationWithStepsMetadata {
    constructor(steps?: CompileAnimationMetadata[]);
}
export class CompileAnimationGroupMetadata extends CompileAnimationWithStepsMetadata {
    constructor(steps?: CompileAnimationMetadata[]);
}
export class CompileIdentifierMetadata implements CompileMetadataWithIdentifier {
    reference: any;
    name: string;
    prefix: string;
    moduleUrl: string;
    value: any;
    constructor({reference, name, moduleUrl, prefix, value}?: {
        reference?: any;
        name?: string;
        moduleUrl?: string;
        prefix?: string;
        value?: any;
    });
    identifier: CompileIdentifierMetadata;
}
export class CompileDiDependencyMetadata {
    isAttribute: boolean;
    isSelf: boolean;
    isHost: boolean;
    isSkipSelf: boolean;
    isOptional: boolean;
    isValue: boolean;
    query: CompileQueryMetadata;
    viewQuery: CompileQueryMetadata;
    token: CompileTokenMetadata;
    value: any;
    constructor({isAttribute, isSelf, isHost, isSkipSelf, isOptional, isValue, query, viewQuery, token, value}?: {
        isAttribute?: boolean;
        isSelf?: boolean;
        isHost?: boolean;
        isSkipSelf?: boolean;
        isOptional?: boolean;
        isValue?: boolean;
        query?: CompileQueryMetadata;
        viewQuery?: CompileQueryMetadata;
        token?: CompileTokenMetadata;
        value?: any;
    });
}
export class CompileProviderMetadata {
    token: CompileTokenMetadata;
    useClass: CompileTypeMetadata;
    useValue: any;
    useExisting: CompileTokenMetadata;
    useFactory: CompileFactoryMetadata;
    deps: CompileDiDependencyMetadata[];
    multi: boolean;
    constructor({token, useClass, useValue, useExisting, useFactory, deps, multi}: {
        token?: CompileTokenMetadata;
        useClass?: CompileTypeMetadata;
        useValue?: any;
        useExisting?: CompileTokenMetadata;
        useFactory?: CompileFactoryMetadata;
        deps?: CompileDiDependencyMetadata[];
        multi?: boolean;
    });
}
export class CompileFactoryMetadata extends CompileIdentifierMetadata {
    diDeps: CompileDiDependencyMetadata[];
    constructor({reference, name, moduleUrl, prefix, diDeps, value}: {
        reference?: Function;
        name?: string;
        prefix?: string;
        moduleUrl?: string;
        value?: boolean;
        diDeps?: CompileDiDependencyMetadata[];
    });
}
export class CompileTokenMetadata implements CompileMetadataWithIdentifier {
    value: any;
    identifier: CompileIdentifierMetadata;
    identifierIsInstance: boolean;
    constructor({value, identifier, identifierIsInstance}: {
        value?: any;
        identifier?: CompileIdentifierMetadata;
        identifierIsInstance?: boolean;
    });
    reference: any;
    name: string;
}
/**
 * Metadata regarding compilation of a type.
 */
export class CompileTypeMetadata extends CompileIdentifierMetadata {
    isHost: boolean;
    diDeps: CompileDiDependencyMetadata[];
    lifecycleHooks: LifecycleHooks[];
    constructor({reference, name, moduleUrl, prefix, isHost, value, diDeps, lifecycleHooks}?: {
        reference?: Type<any>;
        name?: string;
        moduleUrl?: string;
        prefix?: string;
        isHost?: boolean;
        value?: any;
        diDeps?: CompileDiDependencyMetadata[];
        lifecycleHooks?: LifecycleHooks[];
    });
}
export class CompileQueryMetadata {
    selectors: Array<CompileTokenMetadata>;
    descendants: boolean;
    first: boolean;
    propertyName: string;
    read: CompileTokenMetadata;
    constructor({selectors, descendants, first, propertyName, read}?: {
        selectors?: Array<CompileTokenMetadata>;
        descendants?: boolean;
        first?: boolean;
        propertyName?: string;
        read?: CompileTokenMetadata;
    });
}
/**
 * Metadata about a stylesheet
 */
export class CompileStylesheetMetadata {
    moduleUrl: string;
    styles: string[];
    styleUrls: string[];
    constructor({moduleUrl, styles, styleUrls}?: {
        moduleUrl?: string;
        styles?: string[];
        styleUrls?: string[];
    });
}
/**
 * Metadata regarding compilation of a template.
 */
export class CompileTemplateMetadata {
    encapsulation: ViewEncapsulation;
    template: string;
    templateUrl: string;
    styles: string[];
    styleUrls: string[];
    externalStylesheets: CompileStylesheetMetadata[];
    animations: CompileAnimationEntryMetadata[];
    ngContentSelectors: string[];
    interpolation: [string, string];
    constructor({encapsulation, template, templateUrl, styles, styleUrls, externalStylesheets, animations, ngContentSelectors, interpolation}?: {
        encapsulation?: ViewEncapsulation;
        template?: string;
        templateUrl?: string;
        styles?: string[];
        styleUrls?: string[];
        externalStylesheets?: CompileStylesheetMetadata[];
        ngContentSelectors?: string[];
        animations?: CompileAnimationEntryMetadata[];
        interpolation?: [string, string];
    });
}
/**
 * Metadata regarding compilation of a directive.
 */
export class CompileDirectiveMetadata implements CompileMetadataWithIdentifier {
    static create({type, isComponent, selector, exportAs, changeDetection, inputs, outputs, host, providers, viewProviders, queries, viewQueries, entryComponents, template}?: {
        type?: CompileTypeMetadata;
        isComponent?: boolean;
        selector?: string;
        exportAs?: string;
        changeDetection?: ChangeDetectionStrategy;
        inputs?: string[];
        outputs?: string[];
        host?: {
            [key: string]: string;
        };
        providers?: Array<CompileProviderMetadata | CompileTypeMetadata | CompileIdentifierMetadata | any[]>;
        viewProviders?: Array<CompileProviderMetadata | CompileTypeMetadata | CompileIdentifierMetadata | any[]>;
        queries?: CompileQueryMetadata[];
        viewQueries?: CompileQueryMetadata[];
        entryComponents?: CompileTypeMetadata[];
        viewDirectives?: CompileTypeMetadata[];
        viewPipes?: CompileTypeMetadata[];
        template?: CompileTemplateMetadata;
    }): CompileDirectiveMetadata;
    type: CompileTypeMetadata;
    isComponent: boolean;
    selector: string;
    exportAs: string;
    changeDetection: ChangeDetectionStrategy;
    inputs: {
        [key: string]: string;
    };
    outputs: {
        [key: string]: string;
    };
    hostListeners: {
        [key: string]: string;
    };
    hostProperties: {
        [key: string]: string;
    };
    hostAttributes: {
        [key: string]: string;
    };
    providers: CompileProviderMetadata[];
    viewProviders: CompileProviderMetadata[];
    queries: CompileQueryMetadata[];
    viewQueries: CompileQueryMetadata[];
    entryComponents: CompileTypeMetadata[];
    template: CompileTemplateMetadata;
    constructor({type, isComponent, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, providers, viewProviders, queries, viewQueries, entryComponents, template}?: {
        type?: CompileTypeMetadata;
        isComponent?: boolean;
        selector?: string;
        exportAs?: string;
        changeDetection?: ChangeDetectionStrategy;
        inputs?: {
            [key: string]: string;
        };
        outputs?: {
            [key: string]: string;
        };
        hostListeners?: {
            [key: string]: string;
        };
        hostProperties?: {
            [key: string]: string;
        };
        hostAttributes?: {
            [key: string]: string;
        };
        providers?: Array<CompileProviderMetadata | CompileTypeMetadata | CompileIdentifierMetadata | any[]>;
        viewProviders?: Array<CompileProviderMetadata | CompileTypeMetadata | CompileIdentifierMetadata | any[]>;
        queries?: CompileQueryMetadata[];
        viewQueries?: CompileQueryMetadata[];
        entryComponents?: CompileTypeMetadata[];
        viewDirectives?: CompileTypeMetadata[];
        viewPipes?: CompileTypeMetadata[];
        template?: CompileTemplateMetadata;
    });
    identifier: CompileIdentifierMetadata;
}
/**
 * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
 */
export function createHostComponentMeta(compMeta: CompileDirectiveMetadata): CompileDirectiveMetadata;
export class CompilePipeMetadata implements CompileMetadataWithIdentifier {
    type: CompileTypeMetadata;
    name: string;
    pure: boolean;
    constructor({type, name, pure}?: {
        type?: CompileTypeMetadata;
        name?: string;
        pure?: boolean;
    });
    identifier: CompileIdentifierMetadata;
}
/**
 * Metadata regarding compilation of a module.
 */
export class CompileNgModuleMetadata implements CompileMetadataWithIdentifier {
    type: CompileTypeMetadata;
    declaredDirectives: CompileDirectiveMetadata[];
    exportedDirectives: CompileDirectiveMetadata[];
    declaredPipes: CompilePipeMetadata[];
    exportedPipes: CompilePipeMetadata[];
    entryComponents: CompileTypeMetadata[];
    bootstrapComponents: CompileTypeMetadata[];
    providers: CompileProviderMetadata[];
    importedModules: CompileNgModuleMetadata[];
    exportedModules: CompileNgModuleMetadata[];
    schemas: SchemaMetadata[];
    id: string;
    transitiveModule: TransitiveCompileNgModuleMetadata;
    constructor({type, providers, declaredDirectives, exportedDirectives, declaredPipes, exportedPipes, entryComponents, bootstrapComponents, importedModules, exportedModules, schemas, transitiveModule, id}?: {
        type?: CompileTypeMetadata;
        providers?: Array<CompileProviderMetadata | CompileTypeMetadata | CompileIdentifierMetadata | any[]>;
        declaredDirectives?: CompileDirectiveMetadata[];
        exportedDirectives?: CompileDirectiveMetadata[];
        declaredPipes?: CompilePipeMetadata[];
        exportedPipes?: CompilePipeMetadata[];
        entryComponents?: CompileTypeMetadata[];
        bootstrapComponents?: CompileTypeMetadata[];
        importedModules?: CompileNgModuleMetadata[];
        exportedModules?: CompileNgModuleMetadata[];
        transitiveModule?: TransitiveCompileNgModuleMetadata;
        schemas?: SchemaMetadata[];
        id?: string;
    });
    identifier: CompileIdentifierMetadata;
}
export class TransitiveCompileNgModuleMetadata {
    modules: CompileNgModuleMetadata[];
    providers: CompileProviderMetadata[];
    entryComponents: CompileTypeMetadata[];
    directives: CompileDirectiveMetadata[];
    pipes: CompilePipeMetadata[];
    directivesSet: Set<Type<any>>;
    pipesSet: Set<Type<any>>;
    constructor(modules: CompileNgModuleMetadata[], providers: CompileProviderMetadata[], entryComponents: CompileTypeMetadata[], directives: CompileDirectiveMetadata[], pipes: CompilePipeMetadata[]);
}
export function removeIdentifierDuplicates<T extends CompileMetadataWithIdentifier>(items: T[]): T[];
export function isStaticSymbol(value: any): value is StaticSymbol;
export interface StaticSymbol {
    name: string;
    filePath: string;
}
export class ProviderMeta {
    token: any;
    useClass: Type<any>;
    useValue: any;
    useExisting: any;
    useFactory: Function;
    dependencies: Object[];
    multi: boolean;
    constructor(token: any, {useClass, useValue, useExisting, useFactory, deps, multi}: {
        useClass?: Type<any>;
        useValue?: any;
        useExisting?: any;
        useFactory?: Function;
        deps?: Object[];
        multi?: boolean;
    });
}
}
declare module '@angular/compiler/src/compile_metadata' {
export * from '~@angular/compiler/src/compile_metadata';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/abstract_emitter.d.ts
declare module '~@angular/compiler/src/output/abstract_emitter' {
import * as o from '~@angular/compiler/src/output/output_ast';
export const CATCH_ERROR_VAR: o.ReadVarExpr;
export const CATCH_STACK_VAR: o.ReadVarExpr;
export abstract class OutputEmitter {
    abstract emitStatements(moduleUrl: string, stmts: o.Statement[], exportedVars: string[]): string;
}
export class EmitterVisitorContext {
    private _exportedVars;
    private _indent;
    static createRoot(exportedVars: string[]): EmitterVisitorContext;
    private _lines;
    private _classes;
    constructor(_exportedVars: string[], _indent: number);
    private _currentLine;
    isExportedVar(varName: string): boolean;
    println(lastPart?: string): void;
    lineIsEmpty(): boolean;
    print(part: string, newLine?: boolean): void;
    removeEmptyLastLine(): void;
    incIndent(): void;
    decIndent(): void;
    pushClass(clazz: o.ClassStmt): void;
    popClass(): o.ClassStmt;
    currentClass: o.ClassStmt;
    toSource(): any;
}
export abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {
    private _escapeDollarInStrings;
    constructor(_escapeDollarInStrings: boolean);
    visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any;
    visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any;
    abstract visitCastExpr(ast: o.CastExpr, context: any): any;
    abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;
    visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any;
    abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;
    visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any;
    visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any;
    abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;
    visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any;
    visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any;
    visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any;
    visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any;
    abstract getBuiltinMethodName(method: o.BuiltinMethod): string;
    visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any;
    visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any;
    visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any;
    visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext, absentValue?: string): any;
    abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;
    visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any;
    visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any;
    abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;
    abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;
    visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any;
    visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any;
    visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any;
    visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any;
    visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any;
    visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string, newLine?: boolean): void;
    visitAllObjects<T>(handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext, separator: string, newLine?: boolean): void;
    visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void;
}
export function escapeIdentifier(input: string, escapeDollar: boolean, alwaysQuote?: boolean): any;
}
declare module '@angular/compiler/src/output/abstract_emitter' {
export * from '~@angular/compiler/src/output/abstract_emitter';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/offline_compiler.d.ts
declare module '~@angular/compiler/src/offline_compiler' {
import { CompileNgModuleMetadata, StaticSymbol } from '~@angular/compiler/src/compile_metadata';
import { DirectiveNormalizer } from '~@angular/compiler/src/directive_normalizer';
import { DirectiveWrapperCompiler } from '~@angular/compiler/src/directive_wrapper_compiler';
import { CompileMetadataResolver } from '~@angular/compiler/src/metadata_resolver';
import { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
import { OutputEmitter } from '~@angular/compiler/src/output/abstract_emitter';
import { StyleCompiler } from '~@angular/compiler/src/style_compiler';
import { TemplateParser } from '~@angular/compiler/src/template_parser/template_parser';
import { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
export class SourceModule {
    fileUrl: string;
    moduleUrl: string;
    source: string;
    constructor(fileUrl: string, moduleUrl: string, source: string);
}
export function analyzeNgModules(programStaticSymbols: StaticSymbol[], options: {
    transitiveModules: boolean;
}, metadataResolver: CompileMetadataResolver): {
    ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>;
    files: Array<{
        srcUrl: string;
        directives: StaticSymbol[];
        ngModules: StaticSymbol[];
    }>;
};
export class OfflineCompiler {
    private _metadataResolver;
    private _directiveNormalizer;
    private _templateParser;
    private _styleCompiler;
    private _viewCompiler;
    private _dirWrapperCompiler;
    private _ngModuleCompiler;
    private _outputEmitter;
    private _localeId;
    private _translationFormat;
    private _animationParser;
    private _animationCompiler;
    constructor(_metadataResolver: CompileMetadataResolver, _directiveNormalizer: DirectiveNormalizer, _templateParser: TemplateParser, _styleCompiler: StyleCompiler, _viewCompiler: ViewCompiler, _dirWrapperCompiler: DirectiveWrapperCompiler, _ngModuleCompiler: NgModuleCompiler, _outputEmitter: OutputEmitter, _localeId: string, _translationFormat: string);
    clearCache(): void;
    compileModules(staticSymbols: StaticSymbol[], options: {
        transitiveModules: boolean;
    }): Promise<SourceModule[]>;
    private _compileSrcFile(srcFileUrl, ngModuleByPipeOrDirective, directives, ngModules);
    private _compileModule(ngModuleType, targetStatements);
    private _compileDirectiveWrapper(directiveType, targetStatements);
    private _compileComponentFactory(compMeta, fileSuffix, targetStatements);
    private _compileComponent(compMeta, directives, pipes, schemas, componentStyles, fileSuffix, targetStatements);
    private _codgenStyles(fileUrl, stylesCompileResult, fileSuffix);
    private _codegenSourceModule(fileUrl, moduleUrl, statements, exportedVars);
}
}
declare module '@angular/compiler/src/offline_compiler' {
export * from '~@angular/compiler/src/offline_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/runtime_compiler.d.ts
declare module '~@angular/compiler/src/runtime_compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Compiler, Injector, ModuleWithComponentFactories, NgModuleFactory, Type } from '@angular/core';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { DirectiveNormalizer } from '~@angular/compiler/src/directive_normalizer';
import { DirectiveWrapperCompiler } from '~@angular/compiler/src/directive_wrapper_compiler';
import { CompileMetadataResolver } from '~@angular/compiler/src/metadata_resolver';
import { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
import { StyleCompiler } from '~@angular/compiler/src/style_compiler';
import { TemplateParser } from '~@angular/compiler/src/template_parser/template_parser';
import { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
/**
 * An internal module of the Angular compiler that begins with component types,
 * extracts templates, and eventually produces a compiled version of the component
 * ready for linking into an application.
 *
 * @security  When compiling templates at runtime, you must ensure that the entire template comes
 * from a trusted source. Attacker-controlled data introduced by a template could expose your
 * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
 */
export class RuntimeCompiler implements Compiler {
    private _injector;
    private _metadataResolver;
    private _templateNormalizer;
    private _templateParser;
    private _styleCompiler;
    private _viewCompiler;
    private _ngModuleCompiler;
    private _directiveWrapperCompiler;
    private _compilerConfig;
    private _compiledTemplateCache;
    private _compiledHostTemplateCache;
    private _compiledDirectiveWrapperCache;
    private _compiledNgModuleCache;
    private _animationParser;
    private _animationCompiler;
    constructor(_injector: Injector, _metadataResolver: CompileMetadataResolver, _templateNormalizer: DirectiveNormalizer, _templateParser: TemplateParser, _styleCompiler: StyleCompiler, _viewCompiler: ViewCompiler, _ngModuleCompiler: NgModuleCompiler, _directiveWrapperCompiler: DirectiveWrapperCompiler, _compilerConfig: CompilerConfig);
    injector: Injector;
    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;
    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;
    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;
    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;
    private _compileModuleAndComponents<T>(moduleType, isSync);
    private _compileModuleAndAllComponents<T>(moduleType, isSync);
    private _compileModule<T>(moduleType);
    clearCacheFor(type: Type<any>): void;
    clearCache(): void;
    private _createCompiledHostTemplate(compType, ngModule);
    private _createCompiledTemplate(compMeta, ngModule);
    private _assertComponentKnown(compType, isHost);
    private _assertComponentLoaded(compType, isHost);
    private _assertDirectiveWrapper(dirType);
    private _compileDirectiveWrapper(dirMeta, moduleMeta);
    private _compileTemplate(template);
    private _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
    private _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl);
}
}
declare module '@angular/compiler/src/runtime_compiler' {
export * from '~@angular/compiler/src/runtime_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/url_resolver.d.ts
declare module '~@angular/compiler/src/url_resolver' {
/**
 * Create a {@link UrlResolver} with no package prefix.
 */
export function createUrlResolverWithoutPackagePrefix(): UrlResolver;
export function createOfflineCompileUrlResolver(): UrlResolver;
/**
 * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
 */
export var DEFAULT_PACKAGE_URL_PROVIDER: {
    provide: any;
    useValue: string;
};
/**
 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
 *
 * This class can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 *
 * ## Example
 *
 * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}
 *
 * @security  When compiling templates at runtime, you must
 * ensure that the entire template comes from a trusted source.
 * Attacker-controlled data introduced by a template could expose your
 * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
 */
export class UrlResolver {
    private _packagePrefix;
    constructor(_packagePrefix?: string);
    /**
     * Resolves the `url` given the `baseUrl`:
     * - when the `url` is null, the `baseUrl` is returned,
     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
     * `baseUrl` and `url`,
     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
     * returned as is (ignoring the `baseUrl`)
     */
    resolve(baseUrl: string, url: string): string;
}
/**
 * Extract the scheme of a URL.
 */
export function getUrlScheme(url: string): string;
}
declare module '@angular/compiler/src/url_resolver' {
export * from '~@angular/compiler/src/url_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/resource_loader.d.ts
declare module '~@angular/compiler/src/resource_loader' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An interface for retrieving documents by URL that the compiler uses
 * to load templates.
 */
export class ResourceLoader {
    get(url: string): Promise<string>;
}
}
declare module '@angular/compiler/src/resource_loader' {
export * from '~@angular/compiler/src/resource_loader';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/compiler.d.ts
declare module '~@angular/compiler/src/compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Compiler, CompilerFactory, CompilerOptions, PlatformRef, Provider, Type } from '@angular/core';
/**
 * A set of providers that provide `RuntimeCompiler` and its dependencies to use for
 * template compilation.
 */
export const COMPILER_PROVIDERS: Array<any | Type<any> | {
    [k: string]: any;
} | any[]>;
export class RuntimeCompilerFactory implements CompilerFactory {
    private _defaultOptions;
    constructor(defaultOptions: CompilerOptions[]);
    createCompiler(options?: CompilerOptions[]): Compiler;
}
/**
 * A platform that included corePlatform and the compiler.
 *
 * @experimental
 */
export const platformCoreDynamic: (extraProviders?: Provider[]) => PlatformRef;
}
declare module '@angular/compiler/src/compiler' {
export * from '~@angular/compiler/src/compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/directive_resolver.d.ts
declare module '~@angular/compiler/src/directive_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, Type } from '@angular/core';
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
export class DirectiveResolver {
    private _reflector;
    constructor(_reflector?: ReflectorReader);
    /**
     * Return {@link Directive} for a given `Type`.
     */
    resolve(type: Type<any>, throwIfNotFound?: boolean): Directive;
    private _mergeWithPropertyMetadata(dm, propertyMetadata, directiveType);
    private _extractPublicName(def);
    private _merge(directive, inputs, outputs, host, queries, directiveType);
}
}
declare module '@angular/compiler/src/directive_resolver' {
export * from '~@angular/compiler/src/directive_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/pipe_resolver.d.ts
declare module '~@angular/compiler/src/pipe_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Pipe, Type } from '@angular/core';
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
/**
 * Resolve a `Type` for {@link Pipe}.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
export class PipeResolver {
    private _reflector;
    constructor(_reflector?: ReflectorReader);
    /**
     * Return {@link Pipe} for a given `Type`.
     */
    resolve(type: Type<any>, throwIfNotFound?: boolean): Pipe;
}
}
declare module '@angular/compiler/src/pipe_resolver' {
export * from '~@angular/compiler/src/pipe_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ng_module_resolver.d.ts
declare module '~@angular/compiler/src/ng_module_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NgModule, Type } from '@angular/core';
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
/**
 * Resolves types to {@link NgModule}.
 */
export class NgModuleResolver {
    private _reflector;
    constructor(_reflector?: ReflectorReader);
    resolve(type: Type<any>, throwIfNotFound?: boolean): NgModule;
}
}
declare module '@angular/compiler/src/ng_module_resolver' {
export * from '~@angular/compiler/src/ng_module_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/interpolation_config.d.ts
declare module '~@angular/compiler/src/ml_parser/interpolation_config' {
export class InterpolationConfig {
    start: string;
    end: string;
    static fromArray(markers: [string, string]): InterpolationConfig;
    constructor(start: string, end: string);
}
export const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig;
}
declare module '@angular/compiler/src/ml_parser/interpolation_config' {
export * from '~@angular/compiler/src/ml_parser/interpolation_config';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/schema/element_schema_registry.d.ts
declare module '~@angular/compiler/src/schema/element_schema_registry' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SchemaMetadata, SecurityContext } from '@angular/core';
export abstract class ElementSchemaRegistry {
    abstract hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;
    abstract hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;
    abstract securityContext(elementName: string, propName: string, isAttribute: boolean): SecurityContext;
    abstract allKnownElementNames(): string[];
    abstract getMappedPropName(propName: string): string;
    abstract getDefaultComponentElementName(): string;
    abstract validateProperty(name: string): {
        error: boolean;
        msg?: string;
    };
    abstract validateAttribute(name: string): {
        error: boolean;
        msg?: string;
    };
}
}
declare module '@angular/compiler/src/schema/element_schema_registry' {
export * from '~@angular/compiler/src/schema/element_schema_registry';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/i18n_ast.d.ts
declare module '~@angular/compiler/src/i18n/i18n_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
export class Message {
    nodes: Node[];
    placeholders: {
        [name: string]: string;
    };
    placeholderToMsgIds: {
        [name: string]: string;
    };
    meaning: string;
    description: string;
    /**
     * @param nodes message AST
     * @param placeholders maps placeholder names to static content
     * @param placeholderToMsgIds maps placeholder names to translatable message IDs (used for ICU
     *                            messages)
     * @param meaning
     * @param description
     */
    constructor(nodes: Node[], placeholders: {
        [name: string]: string;
    }, placeholderToMsgIds: {
        [name: string]: string;
    }, meaning: string, description: string);
}
export interface Node {
    visit(visitor: Visitor, context?: any): any;
}
export class Text implements Node {
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Container implements Node {
    children: Node[];
    sourceSpan: ParseSourceSpan;
    constructor(children: Node[], sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Icu implements Node {
    expression: string;
    type: string;
    cases: {
        [k: string]: Node;
    };
    sourceSpan: ParseSourceSpan;
    constructor(expression: string, type: string, cases: {
        [k: string]: Node;
    }, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class TagPlaceholder implements Node {
    tag: string;
    attrs: {
        [k: string]: string;
    };
    startName: string;
    closeName: string;
    children: Node[];
    isVoid: boolean;
    sourceSpan: ParseSourceSpan;
    constructor(tag: string, attrs: {
        [k: string]: string;
    }, startName: string, closeName: string, children: Node[], isVoid: boolean, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Placeholder implements Node {
    value: string;
    name: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, name: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class IcuPlaceholder implements Node {
    value: Icu;
    name: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: Icu, name: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export interface Visitor {
    visitText(text: Text, context?: any): any;
    visitContainer(container: Container, context?: any): any;
    visitIcu(icu: Icu, context?: any): any;
    visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;
    visitPlaceholder(ph: Placeholder, context?: any): any;
    visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;
}
}
declare module '@angular/compiler/src/i18n/i18n_ast' {
export * from '~@angular/compiler/src/i18n/i18n_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/message_bundle.d.ts
declare module '~@angular/compiler/src/i18n/message_bundle' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseError } from '~@angular/compiler/src/parse_util';
import { Message } from '~@angular/compiler/src/i18n/i18n_ast';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
/**
 * A container for message extracted from the templates.
 */
export class MessageBundle {
    private _htmlParser;
    private _implicitTags;
    private _implicitAttrs;
    private _messageMap;
    constructor(_htmlParser: HtmlParser, _implicitTags: string[], _implicitAttrs: {
        [k: string]: string[];
    });
    updateFromTemplate(html: string, url: string, interpolationConfig: InterpolationConfig): ParseError[];
    getMessageMap(): {
        [id: string]: Message;
    };
    write(serializer: Serializer): string;
}
}
declare module '@angular/compiler/src/i18n/message_bundle' {
export * from '~@angular/compiler/src/i18n/message_bundle';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/ast.d.ts
declare module '~@angular/compiler/src/ml_parser/ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
export interface Node {
    sourceSpan: ParseSourceSpan;
    visit(visitor: Visitor, context: any): any;
}
export class Text implements Node {
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Expansion implements Node {
    switchValue: string;
    type: string;
    cases: ExpansionCase[];
    sourceSpan: ParseSourceSpan;
    switchValueSourceSpan: ParseSourceSpan;
    constructor(switchValue: string, type: string, cases: ExpansionCase[], sourceSpan: ParseSourceSpan, switchValueSourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class ExpansionCase implements Node {
    value: string;
    expression: Node[];
    sourceSpan: ParseSourceSpan;
    valueSourceSpan: ParseSourceSpan;
    expSourceSpan: ParseSourceSpan;
    constructor(value: string, expression: Node[], sourceSpan: ParseSourceSpan, valueSourceSpan: ParseSourceSpan, expSourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Attribute implements Node {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    valueSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan, valueSpan?: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Element implements Node {
    name: string;
    attrs: Attribute[];
    children: Node[];
    sourceSpan: ParseSourceSpan;
    startSourceSpan: ParseSourceSpan;
    endSourceSpan: ParseSourceSpan;
    constructor(name: string, attrs: Attribute[], children: Node[], sourceSpan: ParseSourceSpan, startSourceSpan: ParseSourceSpan, endSourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Comment implements Node {
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export interface Visitor {
    visit?(node: Node, context: any): any;
    visitElement(element: Element, context: any): any;
    visitAttribute(attribute: Attribute, context: any): any;
    visitText(text: Text, context: any): any;
    visitComment(comment: Comment, context: any): any;
    visitExpansion(expansion: Expansion, context: any): any;
    visitExpansionCase(expansionCase: ExpansionCase, context: any): any;
}
export function visitAll(visitor: Visitor, nodes: Node[], context?: any): any[];
}
declare module '@angular/compiler/src/ml_parser/ast' {
export * from '~@angular/compiler/src/ml_parser/ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/serializer.d.ts
declare module '~@angular/compiler/src/i18n/serializers/serializer' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as html from '~@angular/compiler/src/ml_parser/ast';
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
export interface Serializer {
    write(messageMap: {
        [id: string]: i18n.Message;
    }): string;
    load(content: string, url: string, messageBundle: MessageBundle): {
        [id: string]: html.Node[];
    };
}
export function extractPlaceholders(messageBundle: MessageBundle): {
    [id: string]: {
        [name: string]: string;
    };
};
export function extractPlaceholderToIds(messageBundle: MessageBundle): {
    [id: string]: {
        [name: string]: string;
    };
};
}
declare module '@angular/compiler/src/i18n/serializers/serializer' {
export * from '~@angular/compiler/src/i18n/serializers/serializer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xliff.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xliff' {
import * as ml from '~@angular/compiler/src/ml_parser/ast';
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xliff implements Serializer {
    private _htmlParser;
    private _interpolationConfig;
    constructor(_htmlParser: HtmlParser, _interpolationConfig: InterpolationConfig);
    write(messageMap: {
        [id: string]: i18n.Message;
    }): string;
    load(content: string, url: string, messageBundle: MessageBundle): {
        [id: string]: ml.Node[];
    };
}
}
declare module '@angular/compiler/src/i18n/serializers/xliff' {
export * from '~@angular/compiler/src/i18n/serializers/xliff';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xmb.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xmb' {
import * as html from '~@angular/compiler/src/ml_parser/ast';
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xmb implements Serializer {
    write(messageMap: {
        [k: string]: i18n.Message;
    }): string;
    load(content: string, url: string, messageBundle: MessageBundle): {
        [id: string]: html.Node[];
    };
}
}
declare module '@angular/compiler/src/i18n/serializers/xmb' {
export * from '~@angular/compiler/src/i18n/serializers/xmb';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xtb.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xtb' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ml from '~@angular/compiler/src/ml_parser/ast';
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xtb implements Serializer {
    private _htmlParser;
    private _interpolationConfig;
    constructor(_htmlParser: HtmlParser, _interpolationConfig: InterpolationConfig);
    write(messageMap: {
        [id: string]: i18n.Message;
    }): string;
    load(content: string, url: string, messageBundle: MessageBundle): {
        [id: string]: ml.Node[];
    };
}
}
declare module '@angular/compiler/src/i18n/serializers/xtb' {
export * from '~@angular/compiler/src/i18n/serializers/xtb';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/index.d.ts
declare module '~@angular/compiler/src/i18n/index' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { I18NHtmlParser } from '~@angular/compiler/src/i18n/i18n_html_parser';
export { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
export { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export { Xliff } from '~@angular/compiler/src/i18n/serializers/xliff';
export { Xmb } from '~@angular/compiler/src/i18n/serializers/xmb';
export { Xtb } from '~@angular/compiler/src/i18n/serializers/xtb';
}
declare module '@angular/compiler/src/i18n/index' {
export * from '~@angular/compiler/src/i18n/index';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/util.d.ts
declare module '~@angular/compiler/src/util' {
export const MODULE_SUFFIX: string;
export function camelCaseToDashCase(input: string): string;
export function splitAtColon(input: string, defaultValues: string[]): string[];
export function splitAtPeriod(input: string, defaultValues: string[]): string[];
export function sanitizeIdentifier(name: string): string;
export function visitValue(value: any, visitor: ValueVisitor, context: any): any;
export interface ValueVisitor {
    visitArray(arr: any[], context: any): any;
    visitStringMap(map: {
        [key: string]: any;
    }, context: any): any;
    visitPrimitive(value: any, context: any): any;
    visitOther(value: any, context: any): any;
}
export class ValueTransformer implements ValueVisitor {
    visitArray(arr: any[], context: any): any;
    visitStringMap(map: {
        [key: string]: any;
    }, context: any): any;
    visitPrimitive(value: any, context: any): any;
    visitOther(value: any, context: any): any;
}
export class SyncAsyncResult<T> {
    syncResult: T;
    asyncResult: Promise<T>;
    constructor(syncResult: T, asyncResult?: Promise<T>);
}
}
declare module '@angular/compiler/src/util' {
export * from '~@angular/compiler/src/util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/directive_normalizer.d.ts
declare module '~@angular/compiler/src/directive_normalizer' {
import { CompileDirectiveMetadata, CompileStylesheetMetadata, CompileTemplateMetadata, CompileTypeMetadata } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { ResourceLoader } from '~@angular/compiler/src/resource_loader';
import { UrlResolver } from '~@angular/compiler/src/url_resolver';
import { SyncAsyncResult } from '~@angular/compiler/src/util';
export class DirectiveNormalizer {
    private _resourceLoader;
    private _urlResolver;
    private _htmlParser;
    private _config;
    private _resourceLoaderCache;
    constructor(_resourceLoader: ResourceLoader, _urlResolver: UrlResolver, _htmlParser: HtmlParser, _config: CompilerConfig);
    clearCache(): void;
    clearCacheFor(normalizedDirective: CompileDirectiveMetadata): void;
    private _fetch(url);
    normalizeDirective(directive: CompileDirectiveMetadata): SyncAsyncResult<CompileDirectiveMetadata>;
    normalizeTemplateSync(directiveType: CompileTypeMetadata, template: CompileTemplateMetadata): CompileTemplateMetadata;
    normalizeTemplateAsync(directiveType: CompileTypeMetadata, template: CompileTemplateMetadata): Promise<CompileTemplateMetadata>;
    normalizeLoadedTemplate(directiveType: CompileTypeMetadata, templateMeta: CompileTemplateMetadata, template: string, templateAbsUrl: string): CompileTemplateMetadata;
    normalizeExternalStylesheets(templateMeta: CompileTemplateMetadata): Promise<CompileTemplateMetadata>;
    private _loadMissingExternalStylesheets(styleUrls, loadedStylesheets?);
    normalizeStylesheet(stylesheet: CompileStylesheetMetadata): CompileStylesheetMetadata;
}
}
declare module '@angular/compiler/src/directive_normalizer' {
export * from '~@angular/compiler/src/directive_normalizer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/lexer.d.ts
declare module '~@angular/compiler/src/expression_parser/lexer' {
export enum TokenType {
    Character = 0,
    Identifier = 1,
    Keyword = 2,
    String = 3,
    Operator = 4,
    Number = 5,
    Error = 6,
}
export class Lexer {
    tokenize(text: string): Token[];
}
export class Token {
    index: number;
    type: TokenType;
    numValue: number;
    strValue: string;
    constructor(index: number, type: TokenType, numValue: number, strValue: string);
    isCharacter(code: number): boolean;
    isNumber(): boolean;
    isString(): boolean;
    isOperator(operater: string): boolean;
    isIdentifier(): boolean;
    isKeyword(): boolean;
    isKeywordLet(): boolean;
    isKeywordNull(): boolean;
    isKeywordUndefined(): boolean;
    isKeywordTrue(): boolean;
    isKeywordFalse(): boolean;
    isKeywordThis(): boolean;
    isError(): boolean;
    toNumber(): number;
    toString(): string;
}
export var EOF: Token;
export function isIdentifier(input: string): boolean;
export function isQuote(code: number): boolean;
}
declare module '@angular/compiler/src/expression_parser/lexer' {
export * from '~@angular/compiler/src/expression_parser/lexer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/parser.d.ts
declare module '~@angular/compiler/src/expression_parser/parser' {
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { AST, ASTWithSource, BindingPipe, LiteralMap, ParseSpan, ParserError, TemplateBinding } from '~@angular/compiler/src/expression_parser/ast';
import { Lexer, Token } from '~@angular/compiler/src/expression_parser/lexer';
export class SplitInterpolation {
    strings: string[];
    expressions: string[];
    offsets: number[];
    constructor(strings: string[], expressions: string[], offsets: number[]);
}
export class TemplateBindingParseResult {
    templateBindings: TemplateBinding[];
    warnings: string[];
    errors: ParserError[];
    constructor(templateBindings: TemplateBinding[], warnings: string[], errors: ParserError[]);
}
export class Parser {
    private _lexer;
    private errors;
    constructor(_lexer: Lexer);
    parseAction(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;
    parseBinding(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;
    parseSimpleBinding(input: string, location: string, interpolationConfig?: InterpolationConfig): ASTWithSource;
    private _reportError(message, input, errLocation, ctxLocation?);
    private _parseBindingAst(input, location, interpolationConfig);
    private _parseQuote(input, location);
    parseTemplateBindings(input: string, location: any): TemplateBindingParseResult;
    parseInterpolation(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;
    splitInterpolation(input: string, location: string, interpolationConfig?: InterpolationConfig): SplitInterpolation;
    wrapLiteralPrimitive(input: string, location: any): ASTWithSource;
    private _stripComments(input);
    private _commentStart(input);
    private _checkNoInterpolation(input, location, interpolationConfig);
    private _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig);
}
export class _ParseAST {
    input: string;
    location: any;
    tokens: Token[];
    inputLength: number;
    parseAction: boolean;
    private errors;
    private offset;
    private rparensExpected;
    private rbracketsExpected;
    private rbracesExpected;
    index: number;
    constructor(input: string, location: any, tokens: Token[], inputLength: number, parseAction: boolean, errors: ParserError[], offset: number);
    peek(offset: number): Token;
    next: Token;
    inputIndex: number;
    span(start: number): ParseSpan;
    advance(): void;
    optionalCharacter(code: number): boolean;
    peekKeywordLet(): boolean;
    expectCharacter(code: number): void;
    optionalOperator(op: string): boolean;
    expectOperator(operator: string): void;
    expectIdentifierOrKeyword(): string;
    expectIdentifierOrKeywordOrString(): string;
    parseChain(): AST;
    parsePipe(): AST;
    parseExpression(): AST;
    parseConditional(): AST;
    parseLogicalOr(): AST;
    parseLogicalAnd(): AST;
    parseEquality(): AST;
    parseRelational(): AST;
    parseAdditive(): AST;
    parseMultiplicative(): AST;
    parsePrefix(): AST;
    parseCallChain(): AST;
    parsePrimary(): AST;
    parseExpressionList(terminator: number): AST[];
    parseLiteralMap(): LiteralMap;
    parseAccessMemberOrMethodCall(receiver: AST, isSafe?: boolean): AST;
    parseCallArguments(): BindingPipe[];
    /**
     * An identifier, a keyword, a string with an optional `-` inbetween.
     */
    expectTemplateBindingKey(): string;
    parseTemplateBindings(): TemplateBindingParseResult;
    error(message: string, index?: number): void;
    private locationText(index?);
    private skip();
}
}
declare module '@angular/compiler/src/expression_parser/parser' {
export * from '~@angular/compiler/src/expression_parser/parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/metadata_resolver.d.ts
declare module '~@angular/compiler/src/metadata_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationEntryMetadata, AnimationMetadata, AnimationStateMetadata, AnimationStyleMetadata, Provider, Query, Type } from '@angular/core';
import * as cpl from '~@angular/compiler/src/compile_metadata';
import { DirectiveResolver } from '~@angular/compiler/src/directive_resolver';
import { NgModuleResolver } from '~@angular/compiler/src/ng_module_resolver';
import { PipeResolver } from '~@angular/compiler/src/pipe_resolver';
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
export class CompileMetadataResolver {
    private _ngModuleResolver;
    private _directiveResolver;
    private _pipeResolver;
    private _schemaRegistry;
    private _reflector;
    private _directiveCache;
    private _pipeCache;
    private _ngModuleCache;
    private _ngModuleOfTypes;
    private _anonymousTypes;
    private _anonymousTypeIndex;
    constructor(_ngModuleResolver: NgModuleResolver, _directiveResolver: DirectiveResolver, _pipeResolver: PipeResolver, _schemaRegistry: ElementSchemaRegistry, _reflector?: ReflectorReader);
    private sanitizeTokenName(token);
    clearCacheFor(type: Type<any>): void;
    clearCache(): void;
    getAnimationEntryMetadata(entry: AnimationEntryMetadata): cpl.CompileAnimationEntryMetadata;
    getAnimationStateMetadata(value: AnimationStateMetadata): cpl.CompileAnimationStateMetadata;
    getAnimationStyleMetadata(value: AnimationStyleMetadata): cpl.CompileAnimationStyleMetadata;
    getAnimationMetadata(value: AnimationMetadata): cpl.CompileAnimationMetadata;
    getDirectiveMetadata(directiveType: any, throwIfNotFound?: boolean): cpl.CompileDirectiveMetadata;
    getNgModuleMetadata(moduleType: any, throwIfNotFound?: boolean): cpl.CompileNgModuleMetadata;
    private _verifyModule(moduleMeta);
    private _getTypeDescriptor(type);
    private _addTypeToModule(type, moduleType);
    private _getTransitiveNgModuleMetadata(importedModules, exportedModules);
    private _addDirectiveToModule(dirMeta, moduleType, transitiveModule, declaredDirectives, force?);
    private _addPipeToModule(pipeMeta, moduleType, transitiveModule, declaredPipes, force?);
    getTypeMetadata(type: Type<any>, moduleUrl: string, dependencies?: any[]): cpl.CompileTypeMetadata;
    getFactoryMetadata(factory: Function, moduleUrl: string, dependencies?: any[]): cpl.CompileFactoryMetadata;
    getPipeMetadata(pipeType: Type<any>, throwIfNotFound?: boolean): cpl.CompilePipeMetadata;
    getDependenciesMetadata(typeOrFunc: Type<any> | Function, dependencies: any[]): cpl.CompileDiDependencyMetadata[];
    getTokenMetadata(token: any): cpl.CompileTokenMetadata;
    getProvidersMetadata(providers: Provider[], targetEntryComponents: cpl.CompileTypeMetadata[], debugInfo?: string): Array<cpl.CompileProviderMetadata | cpl.CompileTypeMetadata | any[]>;
    private _getEntryComponentsFromProvider(provider);
    getProviderMetadata(provider: cpl.ProviderMeta): cpl.CompileProviderMetadata;
    getQueriesMetadata(queries: {
        [key: string]: Query;
    }, isViewQuery: boolean, directiveType: Type<any>): cpl.CompileQueryMetadata[];
    private _queryVarBindings(selector);
    getQueryMetadata(q: Query, propertyName: string, typeOrFunc: Type<any> | Function): cpl.CompileQueryMetadata;
}
}
declare module '@angular/compiler/src/metadata_resolver' {
export * from '~@angular/compiler/src/metadata_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/tags.d.ts
declare module '~@angular/compiler/src/ml_parser/tags' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export enum TagContentType {
    RAW_TEXT = 0,
    ESCAPABLE_RAW_TEXT = 1,
    PARSABLE_DATA = 2,
}
export interface TagDefinition {
    closedByParent: boolean;
    requiredParents: {
        [key: string]: boolean;
    };
    parentToAdd: string;
    implicitNamespacePrefix: string;
    contentType: TagContentType;
    isVoid: boolean;
    ignoreFirstLf: boolean;
    canSelfClose: boolean;
    requireExtraParent(currentParent: string): boolean;
    isClosedByChild(name: string): boolean;
}
export function splitNsName(elementName: string): [string, string];
export function getNsPrefix(fullName: string): string;
export function mergeNsAndName(prefix: string, localName: string): string;
export const NAMED_ENTITIES: {
    [k: string]: string;
};
}
declare module '@angular/compiler/src/ml_parser/tags' {
export * from '~@angular/compiler/src/ml_parser/tags';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/parser.d.ts
declare module '~@angular/compiler/src/ml_parser/parser' {
import { ParseError, ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import * as html from '~@angular/compiler/src/ml_parser/ast';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { TagDefinition } from '~@angular/compiler/src/ml_parser/tags';
export class TreeError extends ParseError {
    elementName: string;
    static create(elementName: string, span: ParseSourceSpan, msg: string): TreeError;
    constructor(elementName: string, span: ParseSourceSpan, msg: string);
}
export class ParseTreeResult {
    rootNodes: html.Node[];
    errors: ParseError[];
    constructor(rootNodes: html.Node[], errors: ParseError[]);
}
export class Parser {
    getTagDefinition: (tagName: string) => TagDefinition;
    constructor(getTagDefinition: (tagName: string) => TagDefinition);
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
}
}
declare module '@angular/compiler/src/ml_parser/parser' {
export * from '~@angular/compiler/src/ml_parser/parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/html_parser.d.ts
declare module '~@angular/compiler/src/ml_parser/html_parser' {
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseTreeResult, Parser } from '~@angular/compiler/src/ml_parser/parser';
export { ParseTreeResult, TreeError } from '~@angular/compiler/src/ml_parser/parser';
export class HtmlParser extends Parser {
    constructor();
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
}
}
declare module '@angular/compiler/src/ml_parser/html_parser' {
export * from '~@angular/compiler/src/ml_parser/html_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/output_ast.d.ts
declare module '~@angular/compiler/src/output/output_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
export enum TypeModifier {
    Const = 0,
}
export abstract class Type {
    modifiers: TypeModifier[];
    constructor(modifiers?: TypeModifier[]);
    abstract visitType(visitor: TypeVisitor, context: any): any;
    hasModifier(modifier: TypeModifier): boolean;
}
export enum BuiltinTypeName {
    Dynamic = 0,
    Bool = 1,
    String = 2,
    Int = 3,
    Number = 4,
    Function = 5,
}
export class BuiltinType extends Type {
    name: BuiltinTypeName;
    constructor(name: BuiltinTypeName, modifiers?: TypeModifier[]);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class ExternalType extends Type {
    value: CompileIdentifierMetadata;
    typeParams: Type[];
    constructor(value: CompileIdentifierMetadata, typeParams?: Type[], modifiers?: TypeModifier[]);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class ArrayType extends Type {
    of: Type;
    constructor(of: Type, modifiers?: TypeModifier[]);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class MapType extends Type {
    valueType: Type;
    constructor(valueType: Type, modifiers?: TypeModifier[]);
    visitType(visitor: TypeVisitor, context: any): any;
}
export var DYNAMIC_TYPE: BuiltinType;
export var BOOL_TYPE: BuiltinType;
export var INT_TYPE: BuiltinType;
export var NUMBER_TYPE: BuiltinType;
export var STRING_TYPE: BuiltinType;
export var FUNCTION_TYPE: BuiltinType;
export interface TypeVisitor {
    visitBuiltintType(type: BuiltinType, context: any): any;
    visitExternalType(type: ExternalType, context: any): any;
    visitArrayType(type: ArrayType, context: any): any;
    visitMapType(type: MapType, context: any): any;
}
export enum BinaryOperator {
    Equals = 0,
    NotEquals = 1,
    Identical = 2,
    NotIdentical = 3,
    Minus = 4,
    Plus = 5,
    Divide = 6,
    Multiply = 7,
    Modulo = 8,
    And = 9,
    Or = 10,
    Lower = 11,
    LowerEquals = 12,
    Bigger = 13,
    BiggerEquals = 14,
}
export abstract class Expression {
    type: Type;
    constructor(type: Type);
    abstract visitExpression(visitor: ExpressionVisitor, context: any): any;
    prop(name: string): ReadPropExpr;
    key(index: Expression, type?: Type): ReadKeyExpr;
    callMethod(name: string | BuiltinMethod, params: Expression[]): InvokeMethodExpr;
    callFn(params: Expression[]): InvokeFunctionExpr;
    instantiate(params: Expression[], type?: Type): InstantiateExpr;
    conditional(trueCase: Expression, falseCase?: Expression): ConditionalExpr;
    equals(rhs: Expression): BinaryOperatorExpr;
    notEquals(rhs: Expression): BinaryOperatorExpr;
    identical(rhs: Expression): BinaryOperatorExpr;
    notIdentical(rhs: Expression): BinaryOperatorExpr;
    minus(rhs: Expression): BinaryOperatorExpr;
    plus(rhs: Expression): BinaryOperatorExpr;
    divide(rhs: Expression): BinaryOperatorExpr;
    multiply(rhs: Expression): BinaryOperatorExpr;
    modulo(rhs: Expression): BinaryOperatorExpr;
    and(rhs: Expression): BinaryOperatorExpr;
    or(rhs: Expression): BinaryOperatorExpr;
    lower(rhs: Expression): BinaryOperatorExpr;
    lowerEquals(rhs: Expression): BinaryOperatorExpr;
    bigger(rhs: Expression): BinaryOperatorExpr;
    biggerEquals(rhs: Expression): BinaryOperatorExpr;
    isBlank(): Expression;
    cast(type: Type): Expression;
    toStmt(): Statement;
}
export enum BuiltinVar {
    This = 0,
    Super = 1,
    CatchError = 2,
    CatchStack = 3,
}
export class ReadVarExpr extends Expression {
    name: string;
    builtin: BuiltinVar;
    constructor(name: string | BuiltinVar, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WriteVarExpr;
}
export class WriteVarExpr extends Expression {
    name: string;
    value: Expression;
    constructor(name: string, value: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    toDeclStmt(type?: Type, modifiers?: StmtModifier[]): DeclareVarStmt;
}
export class WriteKeyExpr extends Expression {
    receiver: Expression;
    index: Expression;
    value: Expression;
    constructor(receiver: Expression, index: Expression, value: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class WritePropExpr extends Expression {
    receiver: Expression;
    name: string;
    value: Expression;
    constructor(receiver: Expression, name: string, value: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export enum BuiltinMethod {
    ConcatArray = 0,
    SubscribeObservable = 1,
    Bind = 2,
}
export class InvokeMethodExpr extends Expression {
    receiver: Expression;
    args: Expression[];
    name: string;
    builtin: BuiltinMethod;
    constructor(receiver: Expression, method: string | BuiltinMethod, args: Expression[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class InvokeFunctionExpr extends Expression {
    fn: Expression;
    args: Expression[];
    constructor(fn: Expression, args: Expression[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class InstantiateExpr extends Expression {
    classExpr: Expression;
    args: Expression[];
    constructor(classExpr: Expression, args: Expression[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class LiteralExpr extends Expression {
    value: any;
    constructor(value: any, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ExternalExpr extends Expression {
    value: CompileIdentifierMetadata;
    typeParams: Type[];
    constructor(value: CompileIdentifierMetadata, type?: Type, typeParams?: Type[]);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ConditionalExpr extends Expression {
    condition: Expression;
    falseCase: Expression;
    trueCase: Expression;
    constructor(condition: Expression, trueCase: Expression, falseCase?: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class NotExpr extends Expression {
    condition: Expression;
    constructor(condition: Expression);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class CastExpr extends Expression {
    value: Expression;
    constructor(value: Expression, type: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class FnParam {
    name: string;
    type: Type;
    constructor(name: string, type?: Type);
}
export class FunctionExpr extends Expression {
    params: FnParam[];
    statements: Statement[];
    constructor(params: FnParam[], statements: Statement[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    toDeclStmt(name: string, modifiers?: StmtModifier[]): DeclareFunctionStmt;
}
export class BinaryOperatorExpr extends Expression {
    operator: BinaryOperator;
    rhs: Expression;
    lhs: Expression;
    constructor(operator: BinaryOperator, lhs: Expression, rhs: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ReadPropExpr extends Expression {
    receiver: Expression;
    name: string;
    constructor(receiver: Expression, name: string, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WritePropExpr;
}
export class ReadKeyExpr extends Expression {
    receiver: Expression;
    index: Expression;
    constructor(receiver: Expression, index: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WriteKeyExpr;
}
export class LiteralArrayExpr extends Expression {
    entries: Expression[];
    constructor(entries: Expression[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class LiteralMapExpr extends Expression {
    entries: [string, Expression][];
    valueType: Type;
    constructor(entries: [string, Expression][], type?: MapType);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export interface ExpressionVisitor {
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
}
export var THIS_EXPR: ReadVarExpr;
export var SUPER_EXPR: ReadVarExpr;
export var CATCH_ERROR_VAR: ReadVarExpr;
export var CATCH_STACK_VAR: ReadVarExpr;
export var NULL_EXPR: LiteralExpr;
export enum StmtModifier {
    Final = 0,
    Private = 1,
}
export abstract class Statement {
    modifiers: StmtModifier[];
    constructor(modifiers?: StmtModifier[]);
    abstract visitStatement(visitor: StatementVisitor, context: any): any;
    hasModifier(modifier: StmtModifier): boolean;
}
export class DeclareVarStmt extends Statement {
    name: string;
    value: Expression;
    type: Type;
    constructor(name: string, value: Expression, type?: Type, modifiers?: StmtModifier[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class DeclareFunctionStmt extends Statement {
    name: string;
    params: FnParam[];
    statements: Statement[];
    type: Type;
    constructor(name: string, params: FnParam[], statements: Statement[], type?: Type, modifiers?: StmtModifier[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ExpressionStatement extends Statement {
    expr: Expression;
    constructor(expr: Expression);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ReturnStatement extends Statement {
    value: Expression;
    constructor(value: Expression);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class AbstractClassPart {
    type: Type;
    modifiers: StmtModifier[];
    constructor(type: Type, modifiers: StmtModifier[]);
    hasModifier(modifier: StmtModifier): boolean;
}
export class ClassField extends AbstractClassPart {
    name: string;
    constructor(name: string, type?: Type, modifiers?: StmtModifier[]);
}
export class ClassMethod extends AbstractClassPart {
    name: string;
    params: FnParam[];
    body: Statement[];
    constructor(name: string, params: FnParam[], body: Statement[], type?: Type, modifiers?: StmtModifier[]);
}
export class ClassGetter extends AbstractClassPart {
    name: string;
    body: Statement[];
    constructor(name: string, body: Statement[], type?: Type, modifiers?: StmtModifier[]);
}
export class ClassStmt extends Statement {
    name: string;
    parent: Expression;
    fields: ClassField[];
    getters: ClassGetter[];
    constructorMethod: ClassMethod;
    methods: ClassMethod[];
    constructor(name: string, parent: Expression, fields: ClassField[], getters: ClassGetter[], constructorMethod: ClassMethod, methods: ClassMethod[], modifiers?: StmtModifier[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class IfStmt extends Statement {
    condition: Expression;
    trueCase: Statement[];
    falseCase: Statement[];
    constructor(condition: Expression, trueCase: Statement[], falseCase?: Statement[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class CommentStmt extends Statement {
    comment: string;
    constructor(comment: string);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class TryCatchStmt extends Statement {
    bodyStmts: Statement[];
    catchStmts: Statement[];
    constructor(bodyStmts: Statement[], catchStmts: Statement[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ThrowStmt extends Statement {
    error: Expression;
    constructor(error: Expression);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export interface StatementVisitor {
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
}
export class ExpressionTransformer implements StatementVisitor, ExpressionVisitor {
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
    visitAllExpressions(exprs: Expression[], context: any): Expression[];
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
    visitAllStatements(stmts: Statement[], context: any): Statement[];
}
export class RecursiveExpressionVisitor implements StatementVisitor, ExpressionVisitor {
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
    visitAllExpressions(exprs: Expression[], context: any): void;
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
    visitAllStatements(stmts: Statement[], context: any): void;
}
export function replaceVarInExpression(varName: string, newValue: Expression, expression: Expression): Expression;
export function findReadVarNames(stmts: Statement[]): Set<string>;
export function variable(name: string, type?: Type): ReadVarExpr;
export function importExpr(id: CompileIdentifierMetadata, typeParams?: Type[]): ExternalExpr;
export function importType(id: CompileIdentifierMetadata, typeParams?: Type[], typeModifiers?: TypeModifier[]): ExternalType;
export function literalArr(values: Expression[], type?: Type): LiteralArrayExpr;
export function literalMap(values: [string, Expression][], type?: MapType): LiteralMapExpr;
export function not(expr: Expression): NotExpr;
export function fn(params: FnParam[], body: Statement[], type?: Type): FunctionExpr;
export function literal(value: any, type?: Type): LiteralExpr;
}
declare module '@angular/compiler/src/output/output_ast' {
export * from '~@angular/compiler/src/output/output_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ng_module_compiler.d.ts
declare module '~@angular/compiler/src/ng_module_compiler' {
import { CompileIdentifierMetadata, CompileNgModuleMetadata, CompileProviderMetadata } from '~@angular/compiler/src/compile_metadata';
import * as o from '~@angular/compiler/src/output/output_ast';
export class ComponentFactoryDependency {
    comp: CompileIdentifierMetadata;
    placeholder: CompileIdentifierMetadata;
    constructor(comp: CompileIdentifierMetadata, placeholder: CompileIdentifierMetadata);
}
export class NgModuleCompileResult {
    statements: o.Statement[];
    ngModuleFactoryVar: string;
    dependencies: ComponentFactoryDependency[];
    constructor(statements: o.Statement[], ngModuleFactoryVar: string, dependencies: ComponentFactoryDependency[]);
}
export class NgModuleCompiler {
    compile(ngModuleMeta: CompileNgModuleMetadata, extraProviders: CompileProviderMetadata[]): NgModuleCompileResult;
}
}
declare module '@angular/compiler/src/ng_module_compiler' {
export * from '~@angular/compiler/src/ng_module_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/directive_wrapper_compiler.d.ts
declare module '~@angular/compiler/src/directive_wrapper_compiler' {
import { CompileDirectiveMetadata, CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { Parser } from '~@angular/compiler/src/expression_parser/parser';
import * as o from '~@angular/compiler/src/output/output_ast';
import { Console } from '~@angular/compiler/src/private_import_core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
export class DirectiveWrapperCompileResult {
    statements: o.Statement[];
    dirWrapperClassVar: string;
    constructor(statements: o.Statement[], dirWrapperClassVar: string);
}
/**
 * We generate directive wrappers to prevent code bloat when a directive is used.
 * A directive wrapper encapsulates
 * the dirty checking for `@Input`, the handling of `@HostListener` / `@HostBinding`
 * and calling the lifecyclehooks `ngOnInit`, `ngOnChanges`, `ngDoCheck`.
 *
 * So far, only `@Input` and the lifecycle hooks have been implemented.
 */
export class DirectiveWrapperCompiler {
    private compilerConfig;
    private _exprParser;
    private _schemaRegistry;
    private _console;
    static dirWrapperClassName(id: CompileIdentifierMetadata): string;
    constructor(compilerConfig: CompilerConfig, _exprParser: Parser, _schemaRegistry: ElementSchemaRegistry, _console: Console);
    compile(dirMeta: CompileDirectiveMetadata): DirectiveWrapperCompileResult;
}
}
declare module '@angular/compiler/src/directive_wrapper_compiler' {
export * from '~@angular/compiler/src/directive_wrapper_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/path_util.d.ts
declare module '~@angular/compiler/src/output/path_util' {
/**
 * Interface that defines how import statements should be generated.
 */
export abstract class ImportGenerator {
    static parseAssetUrl(url: string): AssetUrl;
    abstract getImportPath(moduleUrlStr: string, importedUrlStr: string): string;
}
export class AssetUrl {
    packageName: string;
    firstLevelDir: string;
    modulePath: string;
    static parse(url: string, allowNonMatching?: boolean): AssetUrl;
    constructor(packageName: string, firstLevelDir: string, modulePath: string);
}
}
declare module '@angular/compiler/src/output/path_util' {
export * from '~@angular/compiler/src/output/path_util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/ts_emitter.d.ts
declare module '~@angular/compiler/src/output/ts_emitter' {
import { OutputEmitter } from '~@angular/compiler/src/output/abstract_emitter';
import * as o from '~@angular/compiler/src/output/output_ast';
import { ImportGenerator } from '~@angular/compiler/src/output/path_util';
export function debugOutputAstAsTypeScript(ast: o.Statement | o.Expression | o.Type | any[]): string;
export class TypeScriptEmitter implements OutputEmitter {
    private _importGenerator;
    constructor(_importGenerator: ImportGenerator);
    emitStatements(moduleUrl: string, stmts: o.Statement[], exportedVars: string[]): string;
}
}
declare module '@angular/compiler/src/output/ts_emitter' {
export * from '~@angular/compiler/src/output/ts_emitter';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/parse_util.d.ts
declare module '~@angular/compiler/src/parse_util' {
export class ParseLocation {
    file: ParseSourceFile;
    offset: number;
    line: number;
    col: number;
    constructor(file: ParseSourceFile, offset: number, line: number, col: number);
    toString(): string;
}
export class ParseSourceFile {
    content: string;
    url: string;
    constructor(content: string, url: string);
}
export class ParseSourceSpan {
    start: ParseLocation;
    end: ParseLocation;
    details: string;
    constructor(start: ParseLocation, end: ParseLocation, details?: string);
    toString(): string;
}
export enum ParseErrorLevel {
    WARNING = 0,
    FATAL = 1,
}
export class ParseError {
    span: ParseSourceSpan;
    msg: string;
    level: ParseErrorLevel;
    constructor(span: ParseSourceSpan, msg: string, level?: ParseErrorLevel);
    toString(): string;
}
}
declare module '@angular/compiler/src/parse_util' {
export * from '~@angular/compiler/src/parse_util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/schema/dom_element_schema_registry.d.ts
declare module '~@angular/compiler/src/schema/dom_element_schema_registry' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SchemaMetadata, SecurityContext } from '@angular/core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
export class DomElementSchemaRegistry extends ElementSchemaRegistry {
    private _schema;
    constructor();
    hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;
    hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;
    /**
     * securityContext returns the security context for the given property on the given DOM tag.
     *
     * Tag and property name are statically known and cannot change at runtime, i.e. it is not
     * possible to bind a value into a changing attribute or tag name.
     *
     * The filtering is white list based. All attributes in the schema above are assumed to have the
     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
     * attack vectors are assigned their appropriate context.
     */
    securityContext(tagName: string, propName: string, isAttribute: boolean): SecurityContext;
    getMappedPropName(propName: string): string;
    getDefaultComponentElementName(): string;
    validateProperty(name: string): {
        error: boolean;
        msg?: string;
    };
    validateAttribute(name: string): {
        error: boolean;
        msg?: string;
    };
    allKnownElementNames(): string[];
}
}
declare module '@angular/compiler/src/schema/dom_element_schema_registry' {
export * from '~@angular/compiler/src/schema/dom_element_schema_registry';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/selector.d.ts
declare module '~@angular/compiler/src/selector' {
/**
 * A css selector contains an element name,
 * css classes and attribute/value pairs with the purpose
 * of selecting subsets out of them.
 */
export class CssSelector {
    element: string;
    classNames: string[];
    attrs: string[];
    notSelectors: CssSelector[];
    static parse(selector: string): CssSelector[];
    isElementSelector(): boolean;
    hasElementSelector(): boolean;
    setElement(element?: string): void;
    /** Gets a template string for an element that matches the selector. */
    getMatchingElementTemplate(): string;
    addAttribute(name: string, value?: string): void;
    addClassName(name: string): void;
    toString(): string;
}
/**
 * Reads a list of CssSelectors and allows to calculate which ones
 * are contained in a given CssSelector.
 */
export class SelectorMatcher {
    static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher;
    private _elementMap;
    private _elementPartialMap;
    private _classMap;
    private _classPartialMap;
    private _attrValueMap;
    private _attrValuePartialMap;
    private _listContexts;
    addSelectables(cssSelectors: CssSelector[], callbackCtxt?: any): void;
    /**
     * Add an object that can be found later on by calling `match`.
     * @param cssSelector A css selector
     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
     */
    private _addSelectable(cssSelector, callbackCtxt, listContext);
    private _addTerminal(map, name, selectable);
    private _addPartial(map, name);
    /**
     * Find the objects that have been added via `addSelectable`
     * whose css selector is contained in the given css selector.
     * @param cssSelector A css selector
     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
     * @return boolean true if a match was found
    */
    match(cssSelector: CssSelector, matchedCallback: (c: CssSelector, a: any) => void): boolean;
}
export class SelectorListContext {
    selectors: CssSelector[];
    alreadyMatched: boolean;
    constructor(selectors: CssSelector[]);
}
export class SelectorContext {
    selector: CssSelector;
    cbContext: any;
    listContext: SelectorListContext;
    notSelectors: CssSelector[];
    constructor(selector: CssSelector, cbContext: any, listContext: SelectorListContext);
    finalize(cssSelector: CssSelector, callback: (c: CssSelector, a: any) => void): boolean;
}
}
declare module '@angular/compiler/src/selector' {
export * from '~@angular/compiler/src/selector';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/style_compiler.d.ts
declare module '~@angular/compiler/src/style_compiler' {
import { CompileDirectiveMetadata, CompileIdentifierMetadata, CompileStylesheetMetadata } from '~@angular/compiler/src/compile_metadata';
import * as o from '~@angular/compiler/src/output/output_ast';
import { UrlResolver } from '~@angular/compiler/src/url_resolver';
export class StylesCompileDependency {
    moduleUrl: string;
    isShimmed: boolean;
    valuePlaceholder: CompileIdentifierMetadata;
    constructor(moduleUrl: string, isShimmed: boolean, valuePlaceholder: CompileIdentifierMetadata);
}
export class StylesCompileResult {
    componentStylesheet: CompiledStylesheet;
    externalStylesheets: CompiledStylesheet[];
    constructor(componentStylesheet: CompiledStylesheet, externalStylesheets: CompiledStylesheet[]);
}
export class CompiledStylesheet {
    statements: o.Statement[];
    stylesVar: string;
    dependencies: StylesCompileDependency[];
    isShimmed: boolean;
    meta: CompileStylesheetMetadata;
    constructor(statements: o.Statement[], stylesVar: string, dependencies: StylesCompileDependency[], isShimmed: boolean, meta: CompileStylesheetMetadata);
}
export class StyleCompiler {
    private _urlResolver;
    private _shadowCss;
    constructor(_urlResolver: UrlResolver);
    compileComponent(comp: CompileDirectiveMetadata): StylesCompileResult;
    private _compileStyles(comp, stylesheet, isComponentStylesheet);
    private _shimIfNeeded(style, shim);
}
}
declare module '@angular/compiler/src/style_compiler' {
export * from '~@angular/compiler/src/style_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/animation/animation_ast.d.ts
declare module '~@angular/compiler/src/animation/animation_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export abstract class AnimationAst {
    startTime: number;
    playTime: number;
    abstract visit(visitor: AnimationAstVisitor, context: any): any;
}
export abstract class AnimationStateAst extends AnimationAst {
    abstract visit(visitor: AnimationAstVisitor, context: any): any;
}
export interface AnimationAstVisitor {
    visitAnimationEntry(ast: AnimationEntryAst, context: any): any;
    visitAnimationStateDeclaration(ast: AnimationStateDeclarationAst, context: any): any;
    visitAnimationStateTransition(ast: AnimationStateTransitionAst, context: any): any;
    visitAnimationStep(ast: AnimationStepAst, context: any): any;
    visitAnimationSequence(ast: AnimationSequenceAst, context: any): any;
    visitAnimationGroup(ast: AnimationGroupAst, context: any): any;
    visitAnimationKeyframe(ast: AnimationKeyframeAst, context: any): any;
    visitAnimationStyles(ast: AnimationStylesAst, context: any): any;
}
export class AnimationEntryAst extends AnimationAst {
    name: string;
    stateDeclarations: AnimationStateDeclarationAst[];
    stateTransitions: AnimationStateTransitionAst[];
    constructor(name: string, stateDeclarations: AnimationStateDeclarationAst[], stateTransitions: AnimationStateTransitionAst[]);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationStateDeclarationAst extends AnimationStateAst {
    stateName: string;
    styles: AnimationStylesAst;
    constructor(stateName: string, styles: AnimationStylesAst);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationStateTransitionExpression {
    fromState: string;
    toState: string;
    constructor(fromState: string, toState: string);
}
export class AnimationStateTransitionAst extends AnimationStateAst {
    stateChanges: AnimationStateTransitionExpression[];
    animation: AnimationWithStepsAst;
    constructor(stateChanges: AnimationStateTransitionExpression[], animation: AnimationWithStepsAst);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationStepAst extends AnimationAst {
    startingStyles: AnimationStylesAst;
    keyframes: AnimationKeyframeAst[];
    duration: number;
    delay: number;
    easing: string;
    constructor(startingStyles: AnimationStylesAst, keyframes: AnimationKeyframeAst[], duration: number, delay: number, easing: string);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationStylesAst extends AnimationAst {
    styles: Array<{
        [key: string]: string | number;
    }>;
    constructor(styles: Array<{
        [key: string]: string | number;
    }>);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationKeyframeAst extends AnimationAst {
    offset: number;
    styles: AnimationStylesAst;
    constructor(offset: number, styles: AnimationStylesAst);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export abstract class AnimationWithStepsAst extends AnimationAst {
    steps: AnimationAst[];
    constructor(steps: AnimationAst[]);
}
export class AnimationGroupAst extends AnimationWithStepsAst {
    constructor(steps: AnimationAst[]);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationSequenceAst extends AnimationWithStepsAst {
    constructor(steps: AnimationAst[]);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
}
declare module '@angular/compiler/src/animation/animation_ast' {
export * from '~@angular/compiler/src/animation/animation_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/animation/animation_compiler.d.ts
declare module '~@angular/compiler/src/animation/animation_compiler' {
import * as o from '~@angular/compiler/src/output/output_ast';
import { AnimationEntryAst } from '~@angular/compiler/src/animation/animation_ast';
export class AnimationEntryCompileResult {
    name: string;
    statements: o.Statement[];
    fnExp: o.Expression;
    constructor(name: string, statements: o.Statement[], fnExp: o.Expression);
}
export class AnimationCompiler {
    compile(factoryNamePrefix: string, parsedAnimations: AnimationEntryAst[]): AnimationEntryCompileResult[];
}
}
declare module '@angular/compiler/src/animation/animation_compiler' {
export * from '~@angular/compiler/src/animation/animation_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/view_compiler/deps.d.ts
declare module '~@angular/compiler/src/view_compiler/deps' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
export class ViewFactoryDependency {
    comp: CompileIdentifierMetadata;
    placeholder: CompileIdentifierMetadata;
    constructor(comp: CompileIdentifierMetadata, placeholder: CompileIdentifierMetadata);
}
export class ComponentFactoryDependency {
    comp: CompileIdentifierMetadata;
    placeholder: CompileIdentifierMetadata;
    constructor(comp: CompileIdentifierMetadata, placeholder: CompileIdentifierMetadata);
}
export class DirectiveWrapperDependency {
    dir: CompileIdentifierMetadata;
    placeholder: CompileIdentifierMetadata;
    constructor(dir: CompileIdentifierMetadata, placeholder: CompileIdentifierMetadata);
}
}
declare module '@angular/compiler/src/view_compiler/deps' {
export * from '~@angular/compiler/src/view_compiler/deps';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/view_compiler/view_compiler.d.ts
declare module '~@angular/compiler/src/view_compiler/view_compiler' {
import { AnimationEntryCompileResult } from '~@angular/compiler/src/animation/animation_compiler';
import { CompileDirectiveMetadata, CompilePipeMetadata } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import * as o from '~@angular/compiler/src/output/output_ast';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { TemplateAst } from '~@angular/compiler/src/template_parser/template_ast';
import { ComponentFactoryDependency, DirectiveWrapperDependency, ViewFactoryDependency } from '~@angular/compiler/src/view_compiler/deps';
export { ComponentFactoryDependency, DirectiveWrapperDependency, ViewFactoryDependency } from '~@angular/compiler/src/view_compiler/deps';
export class ViewCompileResult {
    statements: o.Statement[];
    viewFactoryVar: string;
    dependencies: Array<ViewFactoryDependency | ComponentFactoryDependency | DirectiveWrapperDependency>;
    constructor(statements: o.Statement[], viewFactoryVar: string, dependencies: Array<ViewFactoryDependency | ComponentFactoryDependency | DirectiveWrapperDependency>);
}
export class ViewCompiler {
    private _genConfig;
    private _schemaRegistry;
    constructor(_genConfig: CompilerConfig, _schemaRegistry: ElementSchemaRegistry);
    compileComponent(component: CompileDirectiveMetadata, template: TemplateAst[], styles: o.Expression, pipes: CompilePipeMetadata[], compiledAnimations: AnimationEntryCompileResult[]): ViewCompileResult;
}
}
declare module '@angular/compiler/src/view_compiler/view_compiler' {
export * from '~@angular/compiler/src/view_compiler/view_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/index.d.ts
declare module '~@angular/compiler/index' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all APIs of the compiler package.
 *
 * <div class="callout is-critical">
 *   <header>Unstable APIs</header>
 *   <p>
 *     All compiler apis are currently considered experimental and private!
 *   </p>
 *   <p>
 *     We expect the APIs in this package to keep on changing. Do not rely on them.
 *   </p>
 * </div>
 */
export * from '~@angular/compiler/src/template_parser/template_ast';
export { TEMPLATE_TRANSFORMS } from '~@angular/compiler/src/template_parser/template_parser';
export { CompilerConfig, RenderTypes } from '~@angular/compiler/src/config';
export * from '~@angular/compiler/src/compile_metadata';
export * from '~@angular/compiler/src/offline_compiler';
export { RuntimeCompiler } from '~@angular/compiler/src/runtime_compiler';
export * from '~@angular/compiler/src/url_resolver';
export * from '~@angular/compiler/src/resource_loader';
export * from '~@angular/compiler/src/compiler';
export { DirectiveResolver } from '~@angular/compiler/src/directive_resolver';
export { PipeResolver } from '~@angular/compiler/src/pipe_resolver';
export { NgModuleResolver } from '~@angular/compiler/src/ng_module_resolver';
export { DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
export * from '~@angular/compiler/src/schema/element_schema_registry';
export * from '~@angular/compiler/src/i18n/index';
export * from '~@angular/compiler/src/directive_normalizer';
export * from '~@angular/compiler/src/expression_parser/lexer';
export * from '~@angular/compiler/src/expression_parser/parser';
export * from '~@angular/compiler/src/metadata_resolver';
export * from '~@angular/compiler/src/ml_parser/html_parser';
export * from '~@angular/compiler/src/ml_parser/interpolation_config';
export { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
export { DirectiveWrapperCompiler } from '~@angular/compiler/src/directive_wrapper_compiler';
export * from '~@angular/compiler/src/output/path_util';
export * from '~@angular/compiler/src/output/ts_emitter';
export * from '~@angular/compiler/src/parse_util';
export * from '~@angular/compiler/src/schema/dom_element_schema_registry';
export * from '~@angular/compiler/src/selector';
export * from '~@angular/compiler/src/style_compiler';
export * from '~@angular/compiler/src/template_parser/template_parser';
export { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
}
declare module '@angular/compiler/index' {
export * from '~@angular/compiler/index';
}
declare module '@angular/compiler' {
export * from '~@angular/compiler/index';
}
