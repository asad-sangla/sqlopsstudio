// Generated by typings
// Source: node_modules/@angular/core/src/metadata/di.d.ts
declare module '~@angular/core/src/metadata/di' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { OpaqueToken } from '~@angular/core/src/di/opaque_token';
import { Type } from '~@angular/core/src/type';
/**
 * This token can be used to create a virtual provider that will populate the
 * `entryComponents` fields of components and ng modules based on its `useValue`.
 * All components that are referenced in the `useValue` value (either directly
 * or in a nested array or map) will be added to the `entryComponents` property.
 *
 * ### Example
 * The following example shows how the router can populate the `entryComponents`
 * field of an NgModule based on the router configuration which refers
 * to components.
 *
 * ```typescript
 * // helper function inside the router
 * function provideRoutes(routes) {
 *   return [
 *     {provide: ROUTES, useValue: routes},
 *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
 *   ];
 * }
 *
 * // user code
 * let routes = [
 *   {path: '/root', component: RootComp},
 *   {path: '/teams', component: TeamsComp}
 * ];
 *
 * @NgModule({
 *   providers: [provideRoutes(routes)]
 * })
 * class ModuleWithRoutes {}
 * ```
 *
 * @experimental
 */
export const ANALYZE_FOR_ENTRY_COMPONENTS: OpaqueToken;
/**
 * Type of the Attribute decorator / constructor function.
 *
 * @stable
 */
export interface AttributeDecorator {
    /**
     * Specifies that a constant attribute value should be injected.
     *
     * The directive can inject constant string literals of host element attributes.
     *
     * ### Example
     *
     * Suppose we have an `<input>` element and want to know its `type`.
     *
     * ```html
     * <input type="text">
     * ```
     *
     * A decorator can inject string literal `text` like so:
     *
     * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
     *
     * ### Example as TypeScript Decorator
     *
     * {@example core/ts/metadata/metadata.ts region='attributeFactory'}
     *
     * ### Example as ES5 DSL
     *
     * ```
     * var MyComponent = ng
     *   .Component({...})
     *   .Class({
     *     constructor: [new ng.Attribute('title'), function(title) {
     *       ...
     *     }]
     *   })
     * ```
     *
     * ### Example as ES5 annotation
     *
     * ```
     * var MyComponent = function(title) {
     *   ...
     * };
     *
     * MyComponent.annotations = [
     *   new ng.Component({...})
     * ]
     * MyComponent.parameters = [
     *   [new ng.Attribute('title')]
     * ]
     * ```
     *
     * @stable
     */
    (name: string): any;
    new (name: string): Attribute;
}
/**
 * Type of the Attribute metadata.
 */
export interface Attribute {
    attributeName?: string;
}
/**
 * Attribute decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Attribute: AttributeDecorator;
/**
 * Type of the Query metadata.
 *
 * @stable
 */
export interface Query {
    descendants: boolean;
    first: boolean;
    read: any;
    isViewQuery: boolean;
    selector: any;
}
/**
 * Base class for query metadata.
 *
 * See {@link ContentChildren}, {@link ContentChild}, {@link ViewChildren}, {@link ViewChild} for
 * more information.
 *
 * @stable
 */
export abstract class Query {
}
/**
 * Type of the ContentChildren decorator / constructor function.
 *
 * See {@link ContentChildren}.
 *
 * @stable
 */
export interface ContentChildrenDecorator {
    /**
     * @whatItDoes Configures a content query.
     *
     * @howToUse
     *
     * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ContentChildren to get the {@link QueryList} of elements or directives from the
     * content DOM. Any time a child element is added, removed, or moved, the query list will be
     * updated,
     * and the changes observable of the query list will emit a new value.
     *
     * Content queries are set before the `ngAfterContentInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **descendants** - include only direct children or all descendants.
     * * **read** - read a different token from the queried elements.
     *
     * Let's look at an example:
     *
     * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    (selector: Type<any> | Function | string, {descendants, read}?: {
        descendants?: boolean;
        read?: any;
    }): any;
    new (selector: Type<any> | Function | string, {descendants, read}?: {
        descendants?: boolean;
        read?: any;
    }): Query;
}
/**
 * Type of the ContentChildren metadata.
 *
 * @stable
 * @Annotation
 */
export type ContentChildren = Query;
/**
 * ContentChildren decorator and metadata.
 *
 *  @stable
 *  @Annotation
 */
export const ContentChildren: ContentChildrenDecorator;
/**
 * Type of the ContentChild decorator / constructor function.
 *
 *
 * @stable
 */
export interface ContentChildDecorator {
    /**
     * @docsNotRequired
     */
    (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): any;
    new (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): ContentChild;
}
/**
 * Type of the ContentChild metadata.
 *
 * See {@link ContentChild}.
 *
 * @stable
 */
export type ContentChild = Query;
/**
 * @whatItDoes Configures a content query.
 *
 * @howToUse
 *
 * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}
 *
 * @description
 *
 * You can use ContentChild to get the first element or the directive matching the selector from the
 * content DOM. If the content DOM changes, and a new child matches the selector,
 * the property will be updated.
 *
 * Content queries are set before the `ngAfterContentInit` callback is called.
 *
 * **Metadata Properties**:
 *
 * * **selector** - the directive type or the name used for querying.
 * * **read** - read a different token from the queried element.
 *
 * Let's look at an example:
 *
 * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}
 *
 * **npm package**: `@angular/core`
 *
 * @stable
 * @Annotation
 */
export const ContentChild: ContentChildDecorator;
/**
 * Type of the ViewChildren decorator / constructor function.
 *
 * See {@ViewChildren}.
 *
 * @stable
 */
export interface ViewChildrenDecorator {
    /**
     * @docsNotRequired
   */ (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): any;
    new (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): ViewChildren;
}
/**
 * Type of the ViewChildren metadata.
 *
 * @stable
 */
export type ViewChildren = Query;
/**
 * @whatItDoes Configures a view query.
 *
 * @howToUse
 *
 * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}
 *
 * @description
 *
 * You can use ViewChildren to get the {@link QueryList} of elements or directives from the
 * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,
 * and the changes observable of the query list will emit a new value.
 *
 * View queries are set before the `ngAfterViewInit` callback is called.
 *
 * **Metadata Properties**:
 *
 * * **selector** - the directive type or the name used for querying.
 * * **read** - read a different token from the queried elements.
 *
 * Let's look at an example:
 *
 * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}
 *
 * **npm package**: `@angular/core`
 *
 * @stable
 * @Annotation
 */
export const ViewChildren: ViewChildrenDecorator;
/**
 * Type of the ViewChild decorator / constructor function.
 *
 * See {@link ViewChild}
 *
 * @stable
 */
export interface ViewChildDecorator {
    /**
     * @whatItDoes Configures a view query.
     *
     * @howToUse
     *
     * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ViewChild to get the first element or the directive matching the selector from the
     * view DOM. If the view DOM changes, and a new child matches the selector,
     * the property will be updated.
     *
     * View queries are set before the `ngAfterViewInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **read** - read a different token from the queried elements.
     *
     * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): any;
    new (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): ViewChild;
}
/**
 * Type of the ViewChild metadata.
 *
 * @stable
 */
export type ViewChild = Query;
/**
 * ViewChild decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const ViewChild: ViewChildDecorator;
}
declare module '@angular/core/src/metadata/di' {
export * from '~@angular/core/src/metadata/di';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata/directives.d.ts
declare module '~@angular/core/src/metadata/directives' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationEntryMetadata } from '~@angular/core/src/animation/metadata';
import { ChangeDetectionStrategy } from '~@angular/core/src/change_detection/constants';
import { Provider } from '~@angular/core/src/di';
import { Type } from '~@angular/core/src/type';
import { TypeDecorator } from '~@angular/core/src/util/decorators';
import { ViewEncapsulation } from '~@angular/core/src/metadata/view';
/**
 * Type of the Directive decorator / constructor function.
 *
 * @stable
 */
export interface DirectiveDecorator {
    /**
     * @whatItDoes Marks a class as an Angular directive and collects directive configuration
     * metadata.
     *
     * @howToUse
     *
     * ```
     * import {Directive} from '@angular/core';
     *
     * @Directive({
     *   selector: 'my-directive',
     * })
     * export class MyDirective {
     * }
     * ```
     *
     * @description
     *
     * Directive decorator allows you to mark a class as an Angular directive and provide additional
     * metadata that determines how the directive should be processed, instantiated and used at
     * runtime.
     *
     * Directives allow you to attach behavior to elements in the DOM..
     *
     * A directive must belong to an NgModule in order for it to be usable
     * by another directive, component, or application. To specify that a directive is a member of an
     * NgModule,
     * you should list it in the `declarations` field of that NgModule.
     *
     * In addition to the metadata configuration specified via the Directive decorator,
     * directives can control their runtime behavior by implementing various Life-Cycle hooks.
     *
     * **Metadata Properties:**
     *
     * * **exportAs** - name under which the component instance is exported in a template
     * * **host** - map of class property to host element bindings for events, properties and
     * attributes
     * * **inputs** - list of class property names to data-bind as component inputs
     * * **outputs** - list of class property names that expose output events that others can
     * subscribe to
     * * **providers** - list of providers available to this component and its children
     * * **queries** -  configure queries that can be injected into the component
     * * **selector** - css selector that identifies this component in a template
     *
     * @stable
     * @Annotation
     */
    (obj: Directive): TypeDecorator;
    /**
     * See the {@link Directive} decorator.
     */
    new (obj: Directive): Directive;
}
export interface Directive {
    /**
     * The CSS selector that triggers the instantiation of a directive.
     *
     * Angular only allows directives to trigger on CSS selectors that do not cross element
     * boundaries.
     *
     * `selector` may be declared as one of the following:
     *
     * - `element-name`: select by element name.
     * - `.class`: select by class name.
     * - `[attribute]`: select by attribute name.
     * - `[attribute=value]`: select by attribute name and value.
     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.
     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.
     *
     *
     * ### Example
     *
     * Suppose we have a directive with an `input[type=text]` selector.
     *
     * And the following HTML:
     *
     * ```html
     * <form>
     *   <input type="text">
     *   <input type="radio">
     * <form>
     * ```
     *
     * The directive would only be instantiated on the `<input type="text">` element.
     *
     */
    selector?: string;
    /**
     * Enumerates the set of data-bound input properties for a directive
     *
     * Angular automatically updates input properties during change detection.
     *
     * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
     * configuration:
     *
     * - `directiveProperty` specifies the component property where the value is written.
     * - `bindingProperty` specifies the DOM property where the value is read from.
     *
     * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
     *
     * The following example creates a component with two data-bound properties.
     *
     * ```typescript
     * @Component({
     *   selector: 'bank-account',
     *   inputs: ['bankName', 'id: account-id'],
     *   template: `
     *     Bank Name: {{bankName}}
     *     Account Id: {{id}}
     *   `
     * })
     * class BankAccount {
     *   bankName: string;
     *   id: string;
     *
     *   // this property is not bound, and won't be automatically updated by Angular
     *   normalizedBankName: string;
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `
     *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
     *   `
     * })
     * class App {}
     * ```
     *
     */
    inputs?: string[];
    /**
     * Enumerates the set of event-bound output properties.
     *
     * When an output property emits an event, an event handler attached to that event
     * the template is invoked.
     *
     * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
     * configuration:
     *
     * - `directiveProperty` specifies the component property that emits events.
     * - `bindingProperty` specifies the DOM property the event handler is attached to.
     *
     * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
     *
     * ```typescript
     * @Directive({
     *   selector: 'interval-dir',
     *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
     * })
     * class IntervalDir {
     *   everySecond = new EventEmitter();
     *   five5Secs = new EventEmitter();
     *
     *   constructor() {
     *     setInterval(() => this.everySecond.emit("event"), 1000);
     *     setInterval(() => this.five5Secs.emit("event"), 5000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `
     *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
     *     </interval-dir>
     *   `
     * })
     * class App {
     *   everySecond() { console.log('second'); }
     *   everyFiveSeconds() { console.log('five seconds'); }
     * }
     * ```
     *
     */
    outputs?: string[];
    /**
     * Specify the events, actions, properties and attributes related to the host element.
     *
     * ## Host Listeners
     *
     * Specifies which DOM events a directive listens to via a set of `(event)` to `method`
     * key-value pairs:
     *
     * - `event`: the DOM event that the directive listens to.
     * - `statement`: the statement to execute when the event occurs.
     * If the evaluation of the statement returns `false`, then `preventDefault`is applied on the DOM
     * event.
     *
     * To listen to global events, a target must be added to the event name.
     * The target can be `window`, `document` or `body`.
     *
     * When writing a directive event binding, you can also refer to the $event local variable.
     *
     * ### Example ([live demo](http://plnkr.co/edit/DlA5KU?p=preview))
     *
     * The following example declares a directive that attaches a click listener to the button and
     * counts clicks.
     *
     * ```typescript
     * @Directive({
     *   selector: 'button[counting]',
     *   host: {
     *     '(click)': 'onClick($event.target)'
     *   }
     * })
     * class CountClicks {
     *   numberOfClicks = 0;
     *
     *   onClick(btn) {
     *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `<button counting>Increment</button>`
     * })
     * class App {}
     * ```
     *
     * ## Host Property Bindings
     *
     * Specifies which DOM properties a directive updates.
     *
     * Angular automatically checks host property bindings during change detection.
     * If a binding changes, it will update the host element of the directive.
     *
     * ### Example ([live demo](http://plnkr.co/edit/gNg0ED?p=preview))
     *
     * The following example creates a directive that sets the `valid` and `invalid` classes
     * on the DOM element that has ngModel directive on it.
     *
     * ```typescript
     * @Directive({
     *   selector: '[ngModel]',
     *   host: {
     *     '[class.valid]': 'valid',
     *     '[class.invalid]': 'invalid'
     *   }
     * })
     * class NgModelStatus {
     *   constructor(public control:NgModel) {}
     *   get valid { return this.control.valid; }
     *   get invalid { return this.control.invalid; }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `<input [(ngModel)]="prop">`
     * })
     * class App {
     *   prop;
     * }
     * ```
     *
     * ## Attributes
     *
     * Specifies static attributes that should be propagated to a host element.
     *
     * ### Example
     *
     * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element
     * (here: `<div>` ) will ensure that this element will get the "button" role.
     *
     * ```typescript
     * @Directive({
     *   selector: '[my-button]',
     *   host: {
     *     'role': 'button'
     *   }
     * })
     * class MyButton {
     * }
     * ```
     */
    host?: {
        [key: string]: string;
    };
    /**
     * Defines the set of injectable objects that are visible to a Directive and its light DOM
     * children.
     *
     * ## Simple Example
     *
     * Here is an example of a class that can be injected:
     *
     * ```
     * class Greeter {
     *    greet(name:string) {
     *      return 'Hello ' + name + '!';
     *    }
     * }
     *
     * @Directive({
     *   selector: 'greet',
     *   providers: [
     *     Greeter
     *   ]
     * })
     * class HelloWorld {
     *   greeter:Greeter;
     *
     *   constructor(greeter:Greeter) {
     *     this.greeter = greeter;
     *   }
     * }
     * ```
     */
    providers?: Provider[];
    /**
     * Defines the name that can be used in the template to assign this directive to a variable.
     *
     * ## Simple Example
     *
     * ```
     * @Directive({
     *   selector: 'child-dir',
     *   exportAs: 'child'
     * })
     * class ChildDir {
     * }
     *
     * @Component({
     *   selector: 'main',
     *   template: `<child-dir #c="child"></child-dir>`
     * })
     * class MainComponent {
     * }
     *
     * ```
     */
    exportAs?: string;
    /**
     * Configures the queries that will be injected into the directive.
     *
     * Content queries are set before the `ngAfterContentInit` callback is called.
     * View queries are set before the `ngAfterViewInit` callback is called.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   selector: 'someDir',
     *   queries: {
     *     contentChildren: new ContentChildren(ChildDirective),
     *     viewChildren: new ViewChildren(ChildDirective)
     *   },
     *   template: '<child-directive></child-directive>'
     * })
     * class SomeDir {
     *   contentChildren: QueryList<ChildDirective>,
     *   viewChildren: QueryList<ChildDirective>
     *
     *   ngAfterContentInit() {
     *     // contentChildren is set
     *   }
     *
     *   ngAfterViewInit() {
     *     // viewChildren is set
     *   }
     * }
     * ```
     */
    queries?: {
        [key: string]: any;
    };
}
/**
 * Directive decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Directive: DirectiveDecorator;
/**
 * Type of the Component decorator / constructor function.
 *
 * @stable
 */
export interface ComponentDecorator {
    /**
     * @whatItDoes Marks a class as an Angular component and collects component configuration
     * metadata.
     *
     * @howToUse
     *
     * {@example core/ts/metadata/metadata.ts region='component'}
     *
     * @description
     * Component decorator allows you to mark a class as an Angular component and provide additional
     * metadata that determines how the component should be processed, instantiated and used at
     * runtime.
     *
     * Components are the most basic building block of an UI in an Angular application.
     * An Angular application is a tree of Angular components.
     * Angular components are a subset of directives. Unlike directives, components always have
     * a template and only one component can be instantiated per an element in a template.
     *
     * A component must belong to an NgModule in order for it to be usable
     * by another component or application. To specify that a component is a member of an NgModule,
     * you should list it in the `declarations` field of that NgModule.
     *
     * In addition to the metadata configuration specified via the Component decorator,
     * components can control their runtime behavior by implementing various Life-Cycle hooks.
     *
     * **Metadata Properties:**
     *
     * * **animations** - list of animations of this component
     * * **changeDetection** - change detection strategy used by this component
     * * **encapsulation** - style encapsulation strategy used by this component
     * * **entryComponents** - list of components that are dynamically inserted into the view of this
     *   component
     * * **exportAs** - name under which the component instance is exported in a template
     * * **host** - map of class property to host element bindings for events, properties and
     *   attributes
     * * **inputs** - list of class property names to data-bind as component inputs
     * * **interpolation** - custom interpolation markers used in this component's template
     * * **moduleId** - ES/CommonJS module id of the file in which this component is defined
     * * **outputs** - list of class property names that expose output events that others can
     *   subscribe to
     * * **providers** - list of providers available to this component and its children
     * * **queries** -  configure queries that can be injected into the component
     * * **selector** - css selector that identifies this component in a template
     * * **styleUrls** - list of urls to stylesheets to be applied to this component's view
     * * **styles** - inline-defined styles to be applied to this component's view
     * * **template** - inline-defined template for the view
     * * **templateUrl** - url to an external file containing a template for the view
     * * **viewProviders** - list of providers available to this component and its view children
     *
     * ### Example
     *
     * {@example core/ts/metadata/metadata.ts region='component'}
     *
     * @stable
     * @Annotation
     */
    (obj: Component): TypeDecorator;
    /**
     * See the {@link Component} decorator.
     */
    new (obj: Component): Component;
}
/**
 * Type of the Component metadata.
 *
 * @stable
 */
export interface Component extends Directive {
    /**
     * Defines the used change detection strategy.
     *
     * When a component is instantiated, Angular creates a change detector, which is responsible for
     * propagating the component's bindings.
     *
     * The `changeDetection` property defines, whether the change detection will be checked every time
     * or only when the component tells it to do so.
     */
    changeDetection?: ChangeDetectionStrategy;
    /**
     * Defines the set of injectable objects that are visible to its view DOM children.
     *
     * ## Simple Example
     *
     * Here is an example of a class that can be injected:
     *
     * ```
     * class Greeter {
     *    greet(name:string) {
     *      return 'Hello ' + name + '!';
     *    }
     * }
     *
     * @Directive({
     *   selector: 'needs-greeter'
     * })
     * class NeedsGreeter {
     *   greeter:Greeter;
     *
     *   constructor(greeter:Greeter) {
     *     this.greeter = greeter;
     *   }
     * }
     *
     * @Component({
     *   selector: 'greet',
     *   viewProviders: [
     *     Greeter
     *   ],
     *   template: `<needs-greeter></needs-greeter>`
     * })
     * class HelloWorld {
     * }
     *
     * ```
     */
    viewProviders?: Provider[];
    /**
     * The module id of the module that contains the component.
     * Needed to be able to resolve relative urls for templates and styles.
     * In CommonJS, this can always be set to `module.id`, similarly SystemJS exposes `__moduleName`
     * variable within each module.
     *
     *
     * ## Simple Example
     *
     * ```
     * @Directive({
     *   selector: 'someDir',
     *   moduleId: module.id
     * })
     * class SomeDir {
     * }
     *
     * ```
     */
    moduleId?: string;
    /**
     * Specifies a template URL for an Angular component.
     *
     *Only one of `templateUrl` or `template` can be defined per View.
     */
    templateUrl?: string;
    /**
     * Specifies an inline template for an Angular component.
     *
     * Only one of `templateUrl` or `template` can be defined per Component.
     */
    template?: string;
    /**
     * Specifies stylesheet URLs for an Angular component.
     */
    styleUrls?: string[];
    /**
     * Specifies inline stylesheets for an Angular component.
     */
    styles?: string[];
    /**
     * Animations are defined on components via an animation-like DSL. This DSL approach to describing
     * animations allows for a flexibility that both benefits developers and the framework.
     *
     * Animations work by listening on state changes that occur on an element within
     * the template. When a state change occurs, Angular can then take advantage and animate the
     * arc in between. This works similar to how CSS transitions work, however, by having a
     * programmatic DSL, animations are not limited to environments that are DOM-specific.
     * (Angular can also perform optimizations behind the scenes to make animations more performant.)
     *
     * For animations to be available for use, animation state changes are placed within
     * {@link trigger animation triggers} which are housed inside of the `animations` annotation
     * metadata. Within a trigger both {@link state state} and {@link transition transition} entries
     * can be placed.
     *
     * ```typescript
     * @Component({
     *   selector: 'animation-cmp',
     *   templateUrl: 'animation-cmp.html',
     *   animations: [
     *     // this here is our animation trigger that
     *     // will contain our state change animations.
     *     trigger('myTriggerName', [
     *       // the styles defined for the `on` and `off`
     *       // states declared below are persisted on the
     *       // element once the animation completes.
     *       state('on', style({ opacity: 1 }),
     *       state('off', style({ opacity: 0 }),
     *
     *       // this here is our animation that kicks off when
     *       // this state change jump is true
     *       transition('on => off', [
     *         animate("1s")
     *       ])
     *     ])
     *   ]
     * })
     * ```
     *
     * As depicted in the code above, a group of related animation states are all contained within
     * an animation `trigger` (the code example above called the trigger `myTriggerName`).
     * When a trigger is created then it can be bound onto an element within the component's
     * template via a property prefixed by an `@` symbol followed by trigger name and an expression
     * that
     * is used to determine the state value for that trigger.
     *
     * ```html
     * <!-- animation-cmp.html -->
     * <div @myTriggerName="expression">...</div>
     * ```
     *
     * For state changes to be executed, the `expression` value must change value from its existing
     * value
     * to something that we have set an animation to animate on (in the example above we are listening
     * to a change of state between `on` and `off`). The `expression` value attached to the trigger
     * must be something that can be evaluated with the template/component context.
     *
     * ### DSL Animation Functions
     *
     * Please visit each of the animation DSL functions listed below to gain a better understanding
     * of how and why they are used for crafting animations in Angular2:
     *
     * - {@link trigger trigger()}
     * - {@link state state()}
     * - {@link transition transition()}
     * - {@link group group()}
     * - {@link sequence sequence()}
     * - {@link style style()}
     * - {@link animate animate()}
     * - {@link keyframes keyframes()}
     */
    animations?: AnimationEntryMetadata[];
    /**
     * Specifies how the template and the styles should be encapsulated:
     * - {@link ViewEncapsulation#Native `ViewEncapsulation.Native`} to use shadow roots - only works
     *   if natively available on the platform,
     * - {@link ViewEncapsulation#Emulated `ViewEncapsulation.Emulated`} to use shimmed CSS that
     *   emulates the native behavior,
     * - {@link ViewEncapsulation#None `ViewEncapsulation.None`} to use global CSS without any
     *   encapsulation.
     *
     * When no `encapsulation` is defined for the component, the default value from the
     * {@link CompilerConfig} is used. The default is `ViewEncapsulation.Emulated`}. Provide a new
     * `CompilerConfig` to override this value.
     *
     * If the encapsulation is set to `ViewEncapsulation.Emulated` and the component has no `styles`
     * nor `styleUrls` the encapsulation will automatically be switched to `ViewEncapsulation.None`.
     */
    encapsulation?: ViewEncapsulation;
    /**
     * Overrides the default encapsulation start and end delimiters (respectively `{{` and `}}`)
     */
    interpolation?: [string, string];
    /**
     * Defines the components that should be compiled as well when
     * this component is defined. For each components listed here,
     * Angular will create a {@link ComponentFactory} and store it in the
     * {@link ComponentFactoryResolver}.
     */
    entryComponents?: Array<Type<any> | any[]>;
}
/**
 * Component decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Component: ComponentDecorator;
/**
 * Type of the Pipe decorator / constructor function.
 *
 * @stable
 */
export interface PipeDecorator {
    /**
     * Declare reusable pipe function.
     *
     * A "pure" pipe is only re-evaluated when either the input or any of the arguments change.
     *
     * When not specified, pipes default to being pure.
     */
    (obj: Pipe): TypeDecorator;
    /**
     * See the {@link Pipe} decorator.
     */
    new (obj: Pipe): Pipe;
}
/**
 * Type of the Pipe metadata.
 *
 * @stable
 */
export interface Pipe {
    name: string;
    pure?: boolean;
}
/**
 * Pipe decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Pipe: PipeDecorator;
/**
 * Type of the Input decorator / constructor function.
 *
 * @stable
 */
export interface InputDecorator {
    /**
     * Declares a data-bound input property.
     *
     * Angular automatically updates data-bound properties during change detection.
     *
     * `Input` takes an optional parameter that specifies the name
     * used when instantiating a component in the template. When not provided,
     * the name of the decorated property is used.
     *
     * ### Example
     *
     * The following example creates a component with two input properties.
     *
     * ```typescript
     * @Component({
     *   selector: 'bank-account',
     *   template: `
     *     Bank Name: {{bankName}}
     *     Account Id: {{id}}
     *   `
     * })
     * class BankAccount {
     *   @Input() bankName: string;
     *   @Input('account-id') id: string;
     *
     *   // this property is not bound, and won't be automatically updated by Angular
     *   normalizedBankName: string;
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `
     *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
     *   `
     * })
     *
     * class App {}
     * ```
     * @stable
     */
    (bindingPropertyName?: string): any;
    new (bindingPropertyName?: string): any;
}
/**
 * Type of the Input metadata.
 *
 * @stable
 */
export interface Input {
    /**
     * Name used when instantiating a component in the template.
     */
    bindingPropertyName?: string;
}
/**
 * Input decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Input: InputDecorator;
/**
 * Type of the Output decorator / constructor function.
 *
 * @stable
 */
export interface OutputDecorator {
    /**
     * Declares an event-bound output property.
     *
     * When an output property emits an event, an event handler attached to that event
     * the template is invoked.
     *
     * `Output` takes an optional parameter that specifies the name
     * used when instantiating a component in the template. When not provided,
     * the name of the decorated property is used.
     *
     * ### Example
     *
     * ```typescript
     * @Directive({
     *   selector: 'interval-dir',
     * })
     * class IntervalDir {
     *   @Output() everySecond = new EventEmitter();
     *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
     *
     *   constructor() {
     *     setInterval(() => this.everySecond.emit("event"), 1000);
     *     setInterval(() => this.five5Secs.emit("event"), 5000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `
     *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
     *     </interval-dir>
     *   `
     * })
     * class App {
     *   everySecond() { console.log('second'); }
     *   everyFiveSeconds() { console.log('five seconds'); }
     * }
     * ```
     * @stable
     */
    (bindingPropertyName?: string): any;
    new (bindingPropertyName?: string): any;
}
/**
 * Type of the Output metadata.
 *
 * @stable
 */
export interface Output {
    bindingPropertyName?: string;
}
/**
 * Output decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Output: OutputDecorator;
/**
 * Type of the HostBinding decorator / constructor function.
 *
 * @stable
 */
export interface HostBindingDecorator {
    /**
     * Declares a host property binding.
     *
     * Angular automatically checks host property bindings during change detection.
     * If a binding changes, it will update the host element of the directive.
     *
     * `HostBinding` takes an optional parameter that specifies the property
     * name of the host element that will be updated. When not provided,
     * the class property name is used.
     *
     * ### Example
     *
     * The following example creates a directive that sets the `valid` and `invalid` classes
     * on the DOM element that has ngModel directive on it.
     *
     * ```typescript
     * @Directive({selector: '[ngModel]'})
     * class NgModelStatus {
     *   constructor(public control:NgModel) {}
     *   @HostBinding('class.valid') get valid() { return this.control.valid; }
     *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `<input [(ngModel)]="prop">`,
     * })
     * class App {
     *   prop;
     * }
     * ```
     * @stable
     */
    (hostPropertyName?: string): any;
    new (hostPropertyName?: string): any;
}
/**
 * Type of the HostBinding metadata.
 *
 * @stable
 */
export interface HostBinding {
    hostPropertyName?: string;
}
/**
 * HostBinding decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const HostBinding: HostBindingDecorator;
/**
 * Type of the HostListener decorator / constructor function.
 *
 * @stable
 */
export interface HostListenerDecorator {
    /**
     * Declares a host listener.
     *
     * Angular will invoke the decorated method when the host element emits the specified event.
     *
     * If the decorated method returns `false`, then `preventDefault` is applied on the DOM event.
     *
     * ### Example
     *
     * The following example declares a directive that attaches a click listener to the button and
     * counts clicks.
     *
     * ```typescript
     * @Directive({selector: 'button[counting]'})
     * class CountClicks {
     *   numberOfClicks = 0;
     *
     *   @HostListener('click', ['$event.target'])
     *   onClick(btn) {
     *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: '<button counting>Increment</button>',
     * })
     * class App {}
     * ```
     * @stable
     * @Annotation
     */
    (eventName: string, args?: string[]): any;
    new (eventName: string, args?: string[]): any;
}
/**
 * Type of the HostListener metadata.
 *
 * @stable
 */
export interface HostListener {
    eventName?: string;
    args?: string[];
}
/**
 * HostBinding decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const HostListener: HostListenerDecorator;
}
declare module '@angular/core/src/metadata/directives' {
export * from '~@angular/core/src/metadata/directives';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata/lifecycle_hooks.d.ts
declare module '~@angular/core/src/metadata/lifecycle_hooks' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SimpleChange } from '~@angular/core/src/change_detection/change_detection_util';
/**
 * @stable
 */
export enum LifecycleHooks {
    OnInit = 0,
    OnDestroy = 1,
    DoCheck = 2,
    OnChanges = 3,
    AfterContentInit = 4,
    AfterContentChecked = 5,
    AfterViewInit = 6,
    AfterViewChecked = 7,
}
/**
 * A `changes` object whose keys are property names and
 * values are instances of {@link SimpleChange}. See {@link OnChanges}
 * @stable
 */
export interface SimpleChanges {
    [propName: string]: SimpleChange;
}
export var LIFECYCLE_HOOKS_VALUES: LifecycleHooks[];
/**
 * @whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
 *
 * @description
 * `ngOnChanges` is called right after the data-bound properties have been checked and before view
 * and content children are checked if at least one of them has changed.
 * The `changes` parameter contains the changed properties.
 *
 * See {@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export abstract class OnChanges {
    abstract ngOnChanges(changes: SimpleChanges): void;
}
/**
 * @whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
 * initialized.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
 *
 * @description
 * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
 * first time, and before any of its children have been checked. It is invoked only once when the
 * directive is instantiated.
 *
 * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export abstract class OnInit {
    abstract ngOnInit(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
 *
 * @description
 * `ngDoCheck` gets called to check the changes in the directives in addition to the default
 * algorithm. The default change detection algorithm looks for differences by comparing
 * bound-property values by reference across change detection runs.
 *
 * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
 * changes on the same input, as `ngOnChanges` will continue to be called when the default change
 * detector detects changes.
 *
 * See {@link KeyValueDiffers} and {@link IterableDiffers} for implementing custom dirty checking
 * for collections.
 *
 * See {@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export abstract class DoCheck {
    abstract ngDoCheck(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called when a directive or pipe is destroyed.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
 *
 * @description
 * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
 * instance is destroyed.
 *
 * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export abstract class OnDestroy {
    abstract ngOnDestroy(): void;
}
/**
 *
 * @whatItDoes Lifecycle hook that is called after a directive's content has been fully
 * initialized.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
 *
 * @description
 * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export abstract class AfterContentInit {
    abstract ngAfterContentInit(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called after every check of a directive's content.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
 *
 * @description
 * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export abstract class AfterContentChecked {
    abstract ngAfterContentChecked(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called after a component's view has been fully
 * initialized.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
 *
 * @description
 * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export abstract class AfterViewInit {
    abstract ngAfterViewInit(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called after every check of a component's view.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
 *
 * @description
 * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export abstract class AfterViewChecked {
    abstract ngAfterViewChecked(): void;
}
}
declare module '@angular/core/src/metadata/lifecycle_hooks' {
export * from '~@angular/core/src/metadata/lifecycle_hooks';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata/ng_module.d.ts
declare module '~@angular/core/src/metadata/ng_module' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Provider } from '~@angular/core/src/di';
import { Type } from '~@angular/core/src/type';
import { TypeDecorator } from '~@angular/core/src/util/decorators';
/**
 * A wrapper around a module that also includes the providers.
 *
 * @stable
 */
export interface ModuleWithProviders {
    ngModule: Type<any>;
    providers?: Provider[];
}
/**
 * Interface for schema definitions in @NgModules.
 *
 * @experimental
 */
export interface SchemaMetadata {
    name: string;
}
/**
 * Defines a schema that will allow:
 * - any non-Angular elements with a `-` in their name,
 * - any properties on elements with a `-` in their name which is the common rule for custom
 * elements.
 *
 * @stable
 */
export const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;
/**
 * Defines a schema that will allow any property on any element.
 *
 * @experimental
 */
export const NO_ERRORS_SCHEMA: SchemaMetadata;
/**
 * Type of the NgModule decorator / constructor function.
 *
 * @stable
 */
export interface NgModuleDecorator {
    /**
     * Defines an NgModule.
     */
    (obj?: NgModule): TypeDecorator;
    new (obj?: NgModule): NgModule;
}
/**
 * Type of the NgModule metadata.
 *
 * @stable
 */
export interface NgModule {
    /**
     * Defines the set of injectable objects that are available in the injector
     * of this module.
     *
     * ## Simple Example
     *
     * Here is an example of a class that can be injected:
     *
     * ```
     * class Greeter {
     *    greet(name:string) {
     *      return 'Hello ' + name + '!';
     *    }
     * }
     *
     * @NgModule({
     *   providers: [
     *     Greeter
     *   ]
     * })
     * class HelloWorld {
     *   greeter:Greeter;
     *
     *   constructor(greeter:Greeter) {
     *     this.greeter = greeter;
     *   }
     * }
     * ```
     */
    providers?: Provider[];
    /**
     * Specifies a list of directives/pipes that belong to this module.
     *
     * ### Example
     *
     * ```javascript
     * @NgModule({
     *   declarations: [NgFor]
     * })
     * class CommonModule {
     * }
     * ```
     */
    declarations?: Array<Type<any> | any[]>;
    /**
     * Specifies a list of modules whose exported directives/pipes
     * should be available to templates in this module.
     * This can also contain {@link ModuleWithProviders}.
     *
     * ### Example
     *
     * ```javascript
     * @NgModule({
     *   imports: [CommonModule]
     * })
     * class MainModule {
     * }
     * ```
     */
    imports?: Array<Type<any> | ModuleWithProviders | any[]>;
    /**
     * Specifies a list of directives/pipes/modules that can be used within the template
     * of any component that is part of an Angular module
     * that imports this Angular module.
     *
     * ### Example
     *
     * ```javascript
     * @NgModule({
     *   exports: [NgFor]
     * })
     * class CommonModule {
     * }
     * ```
     */
    exports?: Array<Type<any> | any[]>;
    /**
     * Specifies a list of components that should be compiled when this module is defined.
     * For each component listed here, Angular will create a {@link ComponentFactory}
     * and store it in the {@link ComponentFactoryResolver}.
     */
    entryComponents?: Array<Type<any> | any[]>;
    /**
     * Defines the components that should be bootstrapped when
     * this module is bootstrapped. The components listed here
     * will automatically be added to `entryComponents`.
     */
    bootstrap?: Array<Type<any> | any[]>;
    /**
     * Elements and properties that are not Angular components nor directives have to be declared in
     * the schema.
     *
     * Available schemas:
     * - `NO_ERRORS_SCHEMA`: any elements and properties are allowed,
     * - `CUSTOM_ELEMENTS_SCHEMA`: any custom elements (tag name has "-") with any properties are
     *   allowed.
     *
     * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA` we're trusting that
     * allowed elements (and its properties) securely escape inputs.
     */
    schemas?: Array<SchemaMetadata | any[]>;
    /**
     * An opaque ID for this module, e.g. a name or a path. Used to identify modules in
     * `getModuleFactory`. If left `undefined`, the `NgModule` will not be registered with
     * `getModuleFactory`.
     */
    id?: string;
}
/**
 * NgModule decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const NgModule: NgModuleDecorator;
}
declare module '@angular/core/src/metadata/ng_module' {
export * from '~@angular/core/src/metadata/ng_module';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata/view.d.ts
declare module '~@angular/core/src/metadata/view' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationEntryMetadata } from '~@angular/core/src/animation/metadata';
/**
 * Defines template and style encapsulation options available for Component's {@link Component}.
 *
 * See {@link ViewMetadata#encapsulation}.
 * @stable
 */
export enum ViewEncapsulation {
    /**
     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
     * Element and pre-processing the style rules provided via
     * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
     * attribute to all selectors.
     *
     * This is the default option.
     */
    Emulated = 0,
    /**
     * Use the native encapsulation mechanism of the renderer.
     *
     * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
     * creating a ShadowRoot for Component's Host Element.
     */
    Native = 1,
    /**
     * Don't provide any template or style encapsulation.
     */
    None = 2,
}
/**
 * Metadata properties available for configuring Views.
 *
 * For details on the `@Component` annotation, see {@link Component}.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 *
 * @deprecated Use Component instead.
 *
 * {@link Component}
 */
export class ViewMetadata {
    /** {@link Component.templateUrl} */
    templateUrl: string;
    /** {@link Component.template} */
    template: string;
    /** {@link Component.stylesUrl} */
    styleUrls: string[];
    /** {@link Component.styles} */
    styles: string[];
    /** {@link Component.encapsulation} */
    encapsulation: ViewEncapsulation;
    /** {@link Component.animation} */
    animations: AnimationEntryMetadata[];
    /** {@link Component.interpolation} */
    interpolation: [string, string];
    constructor({templateUrl, template, encapsulation, styles, styleUrls, animations, interpolation}?: {
        templateUrl?: string;
        template?: string;
        encapsulation?: ViewEncapsulation;
        styles?: string[];
        styleUrls?: string[];
        animations?: AnimationEntryMetadata[];
        interpolation?: [string, string];
    });
}
}
declare module '@angular/core/src/metadata/view' {
export * from '~@angular/core/src/metadata/view';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata.d.ts
declare module '~@angular/core/src/metadata' {
export { ANALYZE_FOR_ENTRY_COMPONENTS, Attribute, ContentChild, ContentChildDecorator, ContentChildren, ContentChildrenDecorator, Query, ViewChild, ViewChildDecorator, ViewChildren, ViewChildrenDecorator } from '~@angular/core/src/metadata/di';
export { Component, ComponentDecorator, Directive, DirectiveDecorator, HostBinding, HostListener, Input, Output, Pipe } from '~@angular/core/src/metadata/directives';
export { AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, DoCheck, OnChanges, OnDestroy, OnInit } from '~@angular/core/src/metadata/lifecycle_hooks';
export { CUSTOM_ELEMENTS_SCHEMA, ModuleWithProviders, NO_ERRORS_SCHEMA, NgModule, SchemaMetadata } from '~@angular/core/src/metadata/ng_module';
export { ViewEncapsulation } from '~@angular/core/src/metadata/view';
}
declare module '@angular/core/src/metadata' {
export * from '~@angular/core/src/metadata';
}

// Generated by typings
// Source: node_modules/@angular/core/src/util/decorators.d.ts
declare module '~@angular/core/src/util/decorators' {
import { Type } from '~@angular/core/src/type';
/**
 * Declares the interface to be used with {@link Class}.
 *
 * @stable
 */
export interface ClassDefinition {
    /**
     * Optional argument for specifying the superclass.
     */
    extends?: Type<any>;
    /**
     * Required constructor function for a class.
     *
     * The function may be optionally wrapped in an `Array`, in which case additional parameter
     * annotations may be specified.
     * The number of arguments and the number of parameter annotations must match.
     *
     * See {@link Class} for example of usage.
     */
    constructor: Function | any[];
    /**
     * Other methods on the class. Note that values should have type 'Function' but TS requires
     * all properties to have a narrower type than the index signature.
     */
    [x: string]: Type<any> | Function | any[];
}
/**
 * An interface implemented by all Angular type decorators, which allows them to be used as ES7
 * decorators as well as
 * Angular DSL syntax.
 *
 * DSL syntax:
 *
 * ```
 * var MyClass = ng
 *   .Component({...})
 *   .Class({...});
 * ```
 *
 * ES7 syntax:
 *
 * ```
 * @ng.Component({...})
 * class MyClass {...}
 * ```
 * @stable
 */
export interface TypeDecorator {
    /**
     * Invoke as ES7 decorator.
     */
    <T extends Type<any>>(type: T): T;
    (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;
    /**
     * Storage for the accumulated annotations so far used by the DSL syntax.
     *
     * Used by {@link Class} to annotate the generated class.
     */
    annotations: any[];
    /**
     * Generate a class from the definition and annotate it with {@link TypeDecorator#annotations}.
     */
    Class(obj: ClassDefinition): Type<any>;
}
/**
 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
 *
 * ## Basic Example
 *
 * ```
 * var Greeter = ng.Class({
 *   constructor: function(name) {
 *     this.name = name;
 *   },
 *
 *   greet: function() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class Greeter {
 *   constructor(name) {
 *     this.name = name;
 *   }
 *
 *   greet() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * }
 * ```
 *
 * or equivalent to ES5:
 *
 * ```
 * var Greeter = function (name) {
 *   this.name = name;
 * }
 *
 * Greeter.prototype.greet = function () {
 *   alert('Hello ' + this.name + '!');
 * }
 * ```
 *
 * ### Example with parameter annotations
 *
 * ```
 * var MyService = ng.Class({
 *   constructor: [String, [new Optional(), Service], function(name, myService) {
 *     ...
 *   }]
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class MyService {
 *   constructor(name: string, @Optional() myService: Service) {
 *     ...
 *   }
 * }
 * ```
 *
 * ### Example with inheritance
 *
 * ```
 * var Shape = ng.Class({
 *   constructor: (color) {
 *     this.color = color;
 *   }
 * });
 *
 * var Square = ng.Class({
 *   extends: Shape,
 *   constructor: function(color, size) {
 *     Shape.call(this, color);
 *     this.size = size;
 *   }
 * });
 * ```
 * @stable
 */
export function Class(clsDef: ClassDefinition): Type<any>;
export function makeDecorator(name: string, props: {
    [name: string]: any;
}, parentClass?: any, chainFn?: (fn: Function) => void): (...args: any[]) => (cls: any) => any;
export function makeParamDecorator(name: string, props: ([string, any] | {
    [name: string]: any;
})[], parentClass?: any): any;
export function makePropDecorator(name: string, props: ([string, any] | {
    [key: string]: any;
})[], parentClass?: any): any;
}
declare module '@angular/core/src/util/decorators' {
export * from '~@angular/core/src/util/decorators';
}

// Generated by typings
// Source: node_modules/@angular/core/src/util.d.ts
declare module '~@angular/core/src/util' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { Class, ClassDefinition, TypeDecorator } from '~@angular/core/src/util/decorators';
}
declare module '@angular/core/src/util' {
export * from '~@angular/core/src/util';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/metadata.d.ts
declare module '~@angular/core/src/di/metadata' {
/**
 * Type of the Inject decorator / constructor function.
 *
 * @stable
 */
export interface InjectDecorator {
    /**
     * @whatItDoes A parameter decorator that specifies a dependency.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@Inject("MyEngine") public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Inject'}
     *
     * When `@Inject()` is not present, {@link Injector} will use the type annotation of the
     * parameter.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='InjectWithoutDecorator'}
     *
     * @stable
     */
    (token: any): any;
    new (token: any): Inject;
}
/**
 * Type of the Inject metadata.
 *
 * @stable
 */
export interface Inject {
    token: any;
}
/**
 * Inject decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Inject: InjectDecorator;
/**
 * Type of the Optional decorator / constructor function.
 *
 * @stable
 */
export interface OptionalDecorator {
    /**
     * @whatItDoes A parameter metadata that marks a dependency as optional.
     * {@link Injector} provides `null` if the dependency is not found.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@Optional() public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Optional'}
     *
     * @stable
     */
    (): any;
    new (): Optional;
}
/**
 * Type of the Optional metadata.
 *
 * @stable
 */
export interface Optional {
}
/**
 * Optional decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Optional: OptionalDecorator;
/**
 * Type of the Injectable decorator / constructor function.
 *
 * @stable
 */
export interface InjectableDecorator {
    /**
     * @whatItDoes A marker metadata that marks a class as available to {@link Injector} for creation.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {}
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Injectable'}
     *
     * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that
     * does not have `@Injectable` marker, as shown in the example below.
     *
     * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}
     *
     * @stable
     */
    (): any;
    new (): Injectable;
}
/**
 * Type of the Injectable metadata.
 *
 * @stable
 */
export interface Injectable {
}
/**
 * Injectable decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Injectable: InjectableDecorator;
/**
 * Type of the Self decorator / constructor function.
 *
 * @stable
 */
export interface SelfDecorator {
    /**
     * @whatItDoes Specifies that an {@link Injector} should retrieve a dependency only from itself.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@Self() public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Self'}
     *
     * @stable
     */
    (): any;
    new (): Self;
}
/**
 * Type of the Self metadata.
 *
 * @stable
 */
export interface Self {
}
/**
 * Self decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Self: SelfDecorator;
/**
 * Type of the SkipSelf decorator / constructor function.
 *
 * @stable
 */
export interface SkipSelfDecorator {
    /**
     * @whatItDoes Specifies that the dependency resolution should start from the parent injector.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@SkipSelf() public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='SkipSelf'}
     *
     * @stable
     */
    (): any;
    new (): SkipSelf;
}
/**
 * Type of the SkipSelf metadata.
 *
 * @stable
 */
export interface SkipSelf {
}
/**
 * SkipSelf decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const SkipSelf: SkipSelfDecorator;
/**
 * Type of the Host decorator / constructor function.
 *
 * @stable
 */
export interface HostDecorator {
    /**
     * @whatItDoes Specifies that an injector should retrieve a dependency from any injector until
     * reaching the host element of the current component.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@Host() public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Host'}
     *
     * @stable
     */
    (): any;
    new (): Host;
}
/**
 * Type of the Host metadata.
 *
 * @stable
 */
export interface Host {
}
/**
 * Host decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Host: HostDecorator;
}
declare module '@angular/core/src/di/metadata' {
export * from '~@angular/core/src/di/metadata';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/forward_ref.d.ts
declare module '~@angular/core/src/di/forward_ref' {
import { Type } from '~@angular/core/src/type';
/**
 * An interface that a function passed into {@link forwardRef} has to implement.
 *
 * ### Example
 *
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}
 * @experimental
 */
export interface ForwardRefFn {
    (): any;
}
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared,
 * but not yet defined. It is also used when the `token` which we use when creating a query is not
 * yet defined.
 *
 * ### Example
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
 * @experimental
 */
export function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;
/**
 * Lazily retrieves the reference value from a forwardRef.
 *
 * Acts as the identity function when given a non-forward-ref value.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
 *
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
 *
 * See: {@link forwardRef}
 * @experimental
 */
export function resolveForwardRef(type: any): any;
}
declare module '@angular/core/src/di/forward_ref' {
export * from '~@angular/core/src/di/forward_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/injector.d.ts
declare module '~@angular/core/src/di/injector' {
export const THROW_IF_NOT_FOUND: Object;
/**
 * @whatItDoes Injector interface
 * @howToUse
 * ```
 * const injector: Injector = ...;
 * injector.get(...);
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 * {@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * @stable
 */
export abstract class Injector {
    static THROW_IF_NOT_FOUND: Object;
    static NULL: Injector;
    /**
     * Retrieves an instance from the injector based on the provided token.
     * If not found:
     * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
     * Injector.THROW_IF_NOT_FOUND is given
     * - Returns the `notFoundValue` otherwise
     */
    get(token: any, notFoundValue?: any): any;
}
}
declare module '@angular/core/src/di/injector' {
export * from '~@angular/core/src/di/injector';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/reflective_injector.d.ts
declare module '~@angular/core/src/di/reflective_injector' {
import { Injector } from '~@angular/core/src/di/injector';
import { Provider } from '~@angular/core/src/di/provider';
import { ResolvedReflectiveProvider } from '~@angular/core/src/di/reflective_provider';
export interface ReflectiveProtoInjectorStrategy {
    getProviderAtIndex(index: number): ResolvedReflectiveProvider;
    createInjectorStrategy(inj: ReflectiveInjector_): ReflectiveInjectorStrategy;
}
export class ReflectiveProtoInjectorInlineStrategy implements ReflectiveProtoInjectorStrategy {
    provider0: ResolvedReflectiveProvider;
    provider1: ResolvedReflectiveProvider;
    provider2: ResolvedReflectiveProvider;
    provider3: ResolvedReflectiveProvider;
    provider4: ResolvedReflectiveProvider;
    provider5: ResolvedReflectiveProvider;
    provider6: ResolvedReflectiveProvider;
    provider7: ResolvedReflectiveProvider;
    provider8: ResolvedReflectiveProvider;
    provider9: ResolvedReflectiveProvider;
    keyId0: number;
    keyId1: number;
    keyId2: number;
    keyId3: number;
    keyId4: number;
    keyId5: number;
    keyId6: number;
    keyId7: number;
    keyId8: number;
    keyId9: number;
    constructor(protoEI: ReflectiveProtoInjector, providers: ResolvedReflectiveProvider[]);
    getProviderAtIndex(index: number): ResolvedReflectiveProvider;
    createInjectorStrategy(injector: ReflectiveInjector_): ReflectiveInjectorStrategy;
}
export class ReflectiveProtoInjectorDynamicStrategy implements ReflectiveProtoInjectorStrategy {
    providers: ResolvedReflectiveProvider[];
    keyIds: number[];
    constructor(protoInj: ReflectiveProtoInjector, providers: ResolvedReflectiveProvider[]);
    getProviderAtIndex(index: number): ResolvedReflectiveProvider;
    createInjectorStrategy(ei: ReflectiveInjector_): ReflectiveInjectorStrategy;
}
export class ReflectiveProtoInjector {
    static fromResolvedProviders(providers: ResolvedReflectiveProvider[]): ReflectiveProtoInjector;
    numberOfProviders: number;
    constructor(providers: ResolvedReflectiveProvider[]);
    getProviderAtIndex(index: number): ResolvedReflectiveProvider;
}
export interface ReflectiveInjectorStrategy {
    getObjByKeyId(keyId: number): any;
    getObjAtIndex(index: number): any;
    getMaxNumberOfObjects(): number;
    resetConstructionCounter(): void;
    instantiateProvider(provider: ResolvedReflectiveProvider): any;
}
export class ReflectiveInjectorInlineStrategy implements ReflectiveInjectorStrategy {
    injector: ReflectiveInjector_;
    protoStrategy: ReflectiveProtoInjectorInlineStrategy;
    obj0: any;
    obj1: any;
    obj2: any;
    obj3: any;
    obj4: any;
    obj5: any;
    obj6: any;
    obj7: any;
    obj8: any;
    obj9: any;
    constructor(injector: ReflectiveInjector_, protoStrategy: ReflectiveProtoInjectorInlineStrategy);
    resetConstructionCounter(): void;
    instantiateProvider(provider: ResolvedReflectiveProvider): any;
    getObjByKeyId(keyId: number): any;
    getObjAtIndex(index: number): any;
    getMaxNumberOfObjects(): number;
}
export class ReflectiveInjectorDynamicStrategy implements ReflectiveInjectorStrategy {
    protoStrategy: ReflectiveProtoInjectorDynamicStrategy;
    injector: ReflectiveInjector_;
    objs: any[];
    constructor(protoStrategy: ReflectiveProtoInjectorDynamicStrategy, injector: ReflectiveInjector_);
    resetConstructionCounter(): void;
    instantiateProvider(provider: ResolvedReflectiveProvider): any;
    getObjByKeyId(keyId: number): any;
    getObjAtIndex(index: number): any;
    getMaxNumberOfObjects(): number;
}
/**
 * A ReflectiveDependency injection container used for instantiating objects and resolving
 * dependencies.
 *
 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
 * constructor dependencies.
 *
 * In typical use, application code asks for the dependencies in the constructor and they are
 * resolved by the `Injector`.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
 *
 * The following example creates an `Injector` configured to create `Engine` and `Car`.
 *
 * ```typescript
 * @Injectable()
 * class Engine {
 * }
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine:Engine) {}
 * }
 *
 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
 * var car = injector.get(Car);
 * expect(car instanceof Car).toBe(true);
 * expect(car.engine instanceof Engine).toBe(true);
 * ```
 *
 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
 * resolve all of the object's dependencies automatically.
 *
 * @stable
 */
export abstract class ReflectiveInjector implements Injector {
    /**
     * Turns an array of provider definitions into an array of resolved providers.
     *
     * A resolution is a process of flattening multiple nested arrays and converting individual
     * providers into an array of {@link ResolvedReflectiveProvider}s.
     *
     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
     *
     * expect(providers.length).toEqual(2);
     *
     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
     * expect(providers[0].key.displayName).toBe("Car");
     * expect(providers[0].dependencies.length).toEqual(1);
     * expect(providers[0].factory).toBeDefined();
     *
     * expect(providers[1].key.displayName).toBe("Engine");
     * });
     * ```
     *
     * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
     */
    static resolve(providers: Provider[]): ResolvedReflectiveProvider[];
    /**
     * Resolves an array of providers and creates an injector from those providers.
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     *
     * This function is slower than the corresponding `fromResolvedProviders`
     * because it needs to resolve the passed-in providers first.
     * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
     */
    static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector;
    /**
     * Creates an injector from previously resolved providers.
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = ReflectiveInjector.resolve([Car, Engine]);
     * var injector = ReflectiveInjector.fromResolvedProviders(providers);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     * @experimental
     */
    static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector): ReflectiveInjector;
    /**
     * Parent of this injector.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
     *
     * ```typescript
     * var parent = ReflectiveInjector.resolveAndCreate([]);
     * var child = parent.resolveAndCreateChild([]);
     * expect(child.parent).toBe(parent);
     * ```
     */
    parent: Injector;
    /**
     * Resolves an array of providers and creates a child injector from those providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
     * var child = parent.resolveAndCreateChild([ChildProvider]);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     *
     * This function is slower than the corresponding `createChildFromResolved`
     * because it needs to resolve the passed-in providers first.
     * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
     */
    resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;
    /**
     * Creates a child injector from previously resolved providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
     *
     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
     * var child = parent.createChildFromResolved(childProviders);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     */
    createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;
    /**
     * Resolves a provider and instantiates an object in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
     *
     * var car = injector.resolveAndInstantiate(Car);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
     * ```
     */
    resolveAndInstantiate(provider: Provider): any;
    /**
     * Instantiates an object using a resolved provider in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
     * var carProvider = ReflectiveInjector.resolve([Car])[0];
     * var car = injector.instantiateResolved(carProvider);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
     * ```
     */
    instantiateResolved(provider: ResolvedReflectiveProvider): any;
    abstract get(token: any, notFoundValue?: any): any;
}
export class ReflectiveInjector_ implements ReflectiveInjector {
    private _strategy;
    /**
     * Private
     */
    constructor(_proto: any, _parent?: Injector);
    get(token: any, notFoundValue?: any): any;
    getAt(index: number): any;
    parent: Injector;
    resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;
    createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;
    resolveAndInstantiate(provider: Provider): any;
    instantiateResolved(provider: ResolvedReflectiveProvider): any;
    private _instantiateProvider(provider);
    private _instantiate(provider, ResolvedReflectiveFactory);
    private _getByReflectiveDependency(provider, dep);
    private _getByKey(key, lowerBoundVisibility, upperBoundVisibility, notFoundValue);
    displayName: string;
    toString(): string;
}
}
declare module '@angular/core/src/di/reflective_injector' {
export * from '~@angular/core/src/di/reflective_injector';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/provider.d.ts
declare module '~@angular/core/src/di/provider' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
/**
 * @whatItDoes Configures the {@link Injector} to return an instance of `Type` when `Type' is used
 * as token.
 * @howToUse
 * ```
 * @Injectable()
 * class MyService {}
 *
 * const provider: TypeProvider = MyService;
 * ```
 *
 * @description
 *
 * Create an instance by invoking the `new` operator and supplying additional arguments.
 * This form is a short form of `TypeProvider`;
 *
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='TypeProvider'}
 *
 * @stable
 */
export interface TypeProvider extends Type<any> {
}
/**
 * @whatItDoes Configures the {@link Injector} to return a value for a token.
 * @howToUse
 * ```
 * const provider: ValueProvider = {provide: 'someToken', useValue: 'someValue'};
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='ValueProvider'}
 *
 * @stable
 */
export interface ValueProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `OpaqueToken`, but can be `any`).
     */
    provide: any;
    /**
     * The value to inject.
     */
    useValue: any;
    /**
     * If true, than injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     *
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
     */
    multi?: boolean;
}
/**
 * @whatItDoes Configures the {@link Injector} to return an instance of `useClass` for a token.
 * @howToUse
 * ```
 * @Injectable()
 * class MyService {}
 *
 * const provider: ClassProvider = {provide: 'someToken', useClass: MyService};
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='ClassProvider'}
 *
 * Note that following two providers are not equal:
 * {@example core/di/ts/provider_spec.ts region='ClassProviderDifference'}
 *
 * @stable
 */
export interface ClassProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `OpaqueToken`, but can be `any`).
     */
    provide: any;
    /**
     * Class to instantiate for the `token`.
     */
    useClass: Type<any>;
    /**
     * If true, than injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     *
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
     */
    multi?: boolean;
}
/**
 * @whatItDoes Configures the {@link Injector} to return a value of another `useExisting` token.
 * @howToUse
 * ```
 * const provider: ExistingProvider = {provide: 'someToken', useExisting: 'someOtherToken'};
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}
 *
 * @stable
 */
export interface ExistingProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `OpaqueToken`, but can be `any`).
     */
    provide: any;
    /**
     * Existing `token` to return. (equivalent to `injector.get(useExisting)`)
     */
    useExisting: any;
    /**
     * If true, than injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     *
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
     */
    multi?: boolean;
}
/**
 * @whatItDoes Configures the {@link Injector} to return a value by invoking a `useFactory`
 * function.
 * @howToUse
 * ```
 * function serviceFactory() { ... }
 *
 * const provider: FactoryProvider = {provide: 'someToken', useFactory: serviceFactory, deps: []};
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}
 *
 * Dependencies can also be marked as optional:
 * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}
 *
 * @stable
 */
export interface FactoryProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `OpaqueToken`, but can be `any`).
     */
    provide: any;
    /**
     * A function to invoke to create a value for this `token`. The function is invoked with
     * resolved values of `token`s in the `deps` field.
     */
    useFactory: Function;
    /**
     * A list of `token`s which need to be resolved by the injector. The list of values is than
     * used as arguments to the `useFactory` function.
     */
    deps?: any[];
    /**
     * If true, than injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     *
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
     */
    multi?: boolean;
}
/**
 * @whatItDoes Describes how the {@link Injector} should be configured.
 * @howToUse
 * See {@link TypeProvider}, {@link ValueProvider}, {@link ClassProvider}, {@link ExistingProvider},
 * {@link FactoryProvider}.
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * @stable
 */
export type Provider = TypeProvider | ValueProvider | ClassProvider | ExistingProvider | FactoryProvider | any[];
}
declare module '@angular/core/src/di/provider' {
export * from '~@angular/core/src/di/provider';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/reflective_provider.d.ts
declare module '~@angular/core/src/di/reflective_provider' {
import { Provider } from '~@angular/core/src/di/provider';
import { ReflectiveKey } from '~@angular/core/src/di/reflective_key';
/**
 * `Dependency` is used by the framework to extend DI.
 * This is internal to Angular and should not be used directly.
 */
export class ReflectiveDependency {
    key: ReflectiveKey;
    optional: boolean;
    lowerBoundVisibility: any;
    upperBoundVisibility: any;
    properties: any[];
    constructor(key: ReflectiveKey, optional: boolean, lowerBoundVisibility: any, upperBoundVisibility: any, properties: any[]);
    static fromKey(key: ReflectiveKey): ReflectiveDependency;
}
/**
 * An internal resolved representation of a {@link Provider} used by the {@link Injector}.
 *
 * It is usually created automatically by `Injector.resolveAndCreate`.
 *
 * It can be created manually, as follows:
 *
 * ### Example ([live demo](http://plnkr.co/edit/RfEnhh8kUEI0G3qsnIeT?p%3Dpreview&p=preview))
 *
 * ```typescript
 * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);
 * var injector = Injector.fromResolvedProviders(resolvedProviders);
 *
 * expect(injector.get('message')).toEqual('Hello');
 * ```
 *
 * @experimental
 */
export interface ResolvedReflectiveProvider {
    /**
     * A key, usually a `Type<any>`.
     */
    key: ReflectiveKey;
    /**
     * Factory function which can return an instance of an object represented by a key.
     */
    resolvedFactories: ResolvedReflectiveFactory[];
    /**
     * Indicates if the provider is a multi-provider or a regular provider.
     */
    multiProvider: boolean;
}
export class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {
    key: ReflectiveKey;
    resolvedFactories: ResolvedReflectiveFactory[];
    multiProvider: boolean;
    constructor(key: ReflectiveKey, resolvedFactories: ResolvedReflectiveFactory[], multiProvider: boolean);
    resolvedFactory: ResolvedReflectiveFactory;
}
/**
 * An internal resolved representation of a factory function created by resolving {@link
 * Provider}.
 * @experimental
 */
export class ResolvedReflectiveFactory {
    /**
     * Factory function which can return an instance of an object represented by a key.
     */
    factory: Function;
    /**
     * Arguments (dependencies) to the `factory` function.
     */
    dependencies: ReflectiveDependency[];
    constructor(
        /**
         * Factory function which can return an instance of an object represented by a key.
         */
        factory: Function, 
        /**
         * Arguments (dependencies) to the `factory` function.
         */
        dependencies: ReflectiveDependency[]);
}
/**
 * Resolve a list of Providers.
 */
export function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[];
/**
 * Merges a list of ResolvedProviders into a list where
 * each key is contained exactly once and multi providers
 * have been merged.
 */
export function mergeResolvedReflectiveProviders(providers: ResolvedReflectiveProvider[], normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>): Map<number, ResolvedReflectiveProvider>;
export function constructDependencies(typeOrFunc: any, dependencies: any[]): ReflectiveDependency[];
}
declare module '@angular/core/src/di/reflective_provider' {
export * from '~@angular/core/src/di/reflective_provider';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/reflective_key.d.ts
declare module '~@angular/core/src/di/reflective_key' {
/**
 * A unique object used for retrieving items from the {@link ReflectiveInjector}.
 *
 * Keys have:
 * - a system-wide unique `id`.
 * - a `token`.
 *
 * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
 * the
 * injector to store created objects in a more efficient way.
 *
 * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
 * resolving
 * providers.
 * @experimental
 */
export class ReflectiveKey {
    token: Object;
    id: number;
    /**
     * Private
     */
    constructor(token: Object, id: number);
    /**
     * Returns a stringified token.
     */
    displayName: string;
    /**
     * Retrieves a `Key` for a token.
     */
    static get(token: Object): ReflectiveKey;
    /**
     * @returns the number of keys registered in the system.
     */
    static numberOfKeys: number;
}
}
declare module '@angular/core/src/di/reflective_key' {
export * from '~@angular/core/src/di/reflective_key';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/opaque_token.d.ts
declare module '~@angular/core/src/di/opaque_token' {
/**
 * Creates a token that can be used in a DI Provider.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
 *
 * ```typescript
 * var t = new OpaqueToken("value");
 *
 * var injector = Injector.resolveAndCreate([
 *   {provide: t, useValue: "bindingValue"}
 * ]);
 *
 * expect(injector.get(t)).toEqual("bindingValue");
 * ```
 *
 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
 * caused by multiple providers using the same string as two different tokens.
 *
 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
 * error messages.
 * @stable
 */
export class OpaqueToken {
    private _desc;
    constructor(_desc: string);
    toString(): string;
}
}
declare module '@angular/core/src/di/opaque_token' {
export * from '~@angular/core/src/di/opaque_token';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di.d.ts
declare module '~@angular/core/src/di' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * The `di` module provides dependency injection container services.
 */
export * from '~@angular/core/src/di/metadata';
export { forwardRef, resolveForwardRef, ForwardRefFn } from '~@angular/core/src/di/forward_ref';
export { Injector } from '~@angular/core/src/di/injector';
export { ReflectiveInjector } from '~@angular/core/src/di/reflective_injector';
export { Provider, TypeProvider, ValueProvider, ClassProvider, ExistingProvider, FactoryProvider } from '~@angular/core/src/di/provider';
export { ResolvedReflectiveFactory, ResolvedReflectiveProvider } from '~@angular/core/src/di/reflective_provider';
export { ReflectiveKey } from '~@angular/core/src/di/reflective_key';
export { OpaqueToken } from '~@angular/core/src/di/opaque_token';
}
declare module '@angular/core/src/di' {
export * from '~@angular/core/src/di';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/change_detector_ref.d.ts
declare module '~@angular/core/src/change_detection/change_detector_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @stable
 */
export abstract class ChangeDetectorRef {
    /**
     * Marks all {@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
     *
     * <!-- TODO: Add a link to a chapter on OnPush components -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
     *
     * ```typescript
     * @Component({
     *   selector: 'cmp',
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     *   template: `Number of ticks: {{numberOfTicks}}`
     * })
     * class Cmp {
     *   numberOfTicks = 0;
     *
     *   constructor(ref: ChangeDetectorRef) {
     *     setInterval(() => {
     *       this.numberOfTicks ++
     *       // the following is required, otherwise the view will not be updated
     *       this.ref.markForCheck();
     *     }, 1000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     *   template: `
     *     <cmp><cmp>
     *   `,
     * })
     * class App {
     * }
     * ```
     */
    abstract markForCheck(): void;
    /**
     * Detaches the change detector from the change detector tree.
     *
     * The detached change detector will not be checked until it is reattached.
     *
     * This can also be used in combination with {@link ChangeDetectorRef#detectChanges} to implement
     * local change
     * detection checks.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
     *
     * ### Example
     *
     * The following example defines a component with a large list of data.
     * Imagine the data changes constantly, many times per second. For performance reasons,
     * we want to check and update the list every five seconds. We can do that by detaching
     * the component's change detector and doing a local check every five seconds.
     *
     * ```typescript
     * class DataProvider {
     *   // in a real application the returned data will be different every time
     *   get data() {
     *     return [1,2,3,4,5];
     *   }
     * }
     *
     * @Component({
     *   selector: 'giant-list',
     *   template: `
     *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
     *   `,
     * })
     * class GiantList {
     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
     *     ref.detach();
     *     setInterval(() => {
     *       this.ref.detectChanges();
     *     }, 5000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   providers: [DataProvider],
     *   template: `
     *     <giant-list><giant-list>
     *   `,
     * })
     * class App {
     * }
     * ```
     */
    abstract detach(): void;
    /**
     * Checks the change detector and its children.
     *
     * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement local
     * change detection
     * checks.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
     *
     * ### Example
     *
     * The following example defines a component with a large list of data.
     * Imagine, the data changes constantly, many times per second. For performance reasons,
     * we want to check and update the list every five seconds.
     *
     * We can do that by detaching the component's change detector and doing a local change detection
     * check
     * every five seconds.
     *
     * See {@link ChangeDetectorRef#detach} for more information.
     */
    abstract detectChanges(): void;
    /**
     * Checks the change detector and its children, and throws if any changes are detected.
     *
     * This is used in development mode to verify that running change detection doesn't introduce
     * other changes.
     */
    abstract checkNoChanges(): void;
    /**
     * Reattach the change detector to the change detector tree.
     *
     * This also marks OnPush ancestors as to be checked. This reattached change detector will be
     * checked during the next change detection run.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
     *
     * The following example creates a component displaying `live` data. The component will detach
     * its change detector from the main change detector tree when the component's live property
     * is set to false.
     *
     * ```typescript
     * class DataProvider {
     *   data = 1;
     *
     *   constructor() {
     *     setInterval(() => {
     *       this.data = this.data * 2;
     *     }, 500);
     *   }
     * }
     *
     * @Component({
     *   selector: 'live-data',
     *   inputs: ['live'],
     *   template: 'Data: {{dataProvider.data}}'
     * })
     * class LiveData {
     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
     *
     *   set live(value) {
     *     if (value)
     *       this.ref.reattach();
     *     else
     *       this.ref.detach();
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   providers: [DataProvider],
     *   template: `
     *     Live Update: <input type="checkbox" [(ngModel)]="live">
     *     <live-data [live]="live"><live-data>
     *   `,
     * })
     * class App {
     *   live = true;
     * }
     * ```
     */
    abstract reattach(): void;
}
}
declare module '@angular/core/src/change_detection/change_detector_ref' {
export * from '~@angular/core/src/change_detection/change_detector_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/console.d.ts
declare module '~@angular/core/src/console' {
export class Console {
    log(message: string): void;
    warn(message: string): void;
}
}
declare module '@angular/core/src/console' {
export * from '~@angular/core/src/console';
}

// Generated by typings
// Source: node_modules/@angular/core/src/facade/errors.d.ts
declare module '~@angular/core/src/facade/errors' {

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export function unimplemented(): any;
/**
 * @stable
 */
export class BaseError extends Error {
    constructor(message: string);
    message: string;
    name: string;
    stack: any;
    toString(): string;
}
/**
 * @stable
 */
export class WrappedError extends BaseError {
    originalError: any;
    constructor(message: string, error: any);
    stack: any;
}
}
declare module '@angular/core/src/facade/errors' {
export * from '~@angular/core/src/facade/errors';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/compiler.d.ts
declare module '~@angular/core/src/linker/compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { OpaqueToken } from '~@angular/core/src/di';
import { BaseError } from '~@angular/core/src/facade/errors';
import { ViewEncapsulation } from '~@angular/core/src/metadata';
import { Type } from '~@angular/core/src/type';
import { ComponentFactory } from '~@angular/core/src/linker/component_factory';
import { NgModuleFactory } from '~@angular/core/src/linker/ng_module_factory';
/**
 * Indicates that a component is still being loaded in a synchronous compile.
 *
 * @stable
 */
export class ComponentStillLoadingError extends BaseError {
    compType: Type<any>;
    constructor(compType: Type<any>);
}
/**
 * Combination of NgModuleFactory and ComponentFactorys.
 *
 * @experimental
 */
export class ModuleWithComponentFactories<T> {
    ngModuleFactory: NgModuleFactory<T>;
    componentFactories: ComponentFactory<any>[];
    constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);
}
/**
 * Low-level service for running the angular compiler during runtime
 * to create {@link ComponentFactory}s, which
 * can later be used to create and render a Component instance.
 *
 * Each `@NgModule` provides an own `Compiler` to its injector,
 * that will use the directives/pipes of the ng module for compilation
 * of components.
 * @stable
 */
export class Compiler {
    /**
     * Compiles the given NgModule and all of its components. All templates of the components listed
     * in `entryComponents`
     * have to be inlined. Otherwise throws a {@link ComponentStillLoadingError}.
     */
    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;
    /**
     * Compiles the given NgModule and all of its components
     */
    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;
    /**
     * Same as {@link compileModuleSync} but also creates ComponentFactories for all components.
     */
    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;
    /**
     * Same as {@link compileModuleAsync} but also creates ComponentFactories for all components.
     */
    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;
    /**
     * Clears all caches.
     */
    clearCache(): void;
    /**
     * Clears the cache for the given component/ngModule.
     */
    clearCacheFor(type: Type<any>): void;
}
/**
 * Options for creating a compiler
 *
 * @experimental
 */
export type CompilerOptions = {
    useDebug?: boolean;
    useJit?: boolean;
    defaultEncapsulation?: ViewEncapsulation;
    providers?: any[];
};
/**
 * Token to provide CompilerOptions in the platform injector.
 *
 * @experimental
 */
export const COMPILER_OPTIONS: OpaqueToken;
/**
 * A factory for creating a Compiler
 *
 * @experimental
 */
export abstract class CompilerFactory {
    abstract createCompiler(options?: CompilerOptions[]): Compiler;
}
}
declare module '@angular/core/src/linker/compiler' {
export * from '~@angular/core/src/linker/compiler';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/component_factory.d.ts
declare module '~@angular/core/src/linker/component_factory' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detection';
import { Injector } from '~@angular/core/src/di/injector';
import { Type } from '~@angular/core/src/type';
import { AppElement } from '~@angular/core/src/linker/element';
import { ElementRef } from '~@angular/core/src/linker/element_ref';
import { ViewRef } from '~@angular/core/src/linker/view_ref';
/**
 * Represents an instance of a Component created via a {@link ComponentFactory}.
 *
 * `ComponentRef` provides access to the Component Instance as well other objects related to this
 * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
 * method.
 * @stable
 */
export abstract class ComponentRef<C> {
    /**
     * Location of the Host Element of this Component Instance.
     */
    location: ElementRef;
    /**
     * The injector on which the component instance exists.
     */
    injector: Injector;
    /**
     * The instance of the Component.
     */
    instance: C;
    /**
     * The {@link ViewRef} of the Host View of this Component instance.
     */
    hostView: ViewRef;
    /**
     * The {@link ChangeDetectorRef} of the Component instance.
     */
    changeDetectorRef: ChangeDetectorRef;
    /**
     * The component type.
     */
    componentType: Type<any>;
    /**
     * Destroys the component instance and all of the data structures associated with it.
     */
    abstract destroy(): void;
    /**
     * Allows to register a callback that will be called when the component is destroyed.
     */
    abstract onDestroy(callback: Function): void;
}
export class ComponentRef_<C> extends ComponentRef<C> {
    private _hostElement;
    private _componentType;
    constructor(_hostElement: AppElement, _componentType: Type<any>);
    location: ElementRef;
    injector: Injector;
    instance: C;
    hostView: ViewRef;
    changeDetectorRef: ChangeDetectorRef;
    componentType: Type<any>;
    destroy(): void;
    onDestroy(callback: Function): void;
}
/**
 * @stable
 */
export class ComponentFactory<C> {
    selector: string;
    private _viewFactory;
    private _componentType;
    constructor(selector: string, _viewFactory: Function, _componentType: Type<any>);
    componentType: Type<any>;
    /**
     * Creates a new component.
     */
    create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any): ComponentRef<C>;
}
}
declare module '@angular/core/src/linker/component_factory' {
export * from '~@angular/core/src/linker/component_factory';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/component_factory_resolver.d.ts
declare module '~@angular/core/src/linker/component_factory_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { BaseError } from '~@angular/core/src/facade/errors';
import { Type } from '~@angular/core/src/type';
import { ComponentFactory } from '~@angular/core/src/linker/component_factory';
/**
 * @stable
 */
export class NoComponentFactoryError extends BaseError {
    component: Function;
    constructor(component: Function);
}
/**
 * @stable
 */
export abstract class ComponentFactoryResolver {
    static NULL: ComponentFactoryResolver;
    abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;
}
export class CodegenComponentFactoryResolver implements ComponentFactoryResolver {
    private _parent;
    private _factories;
    constructor(factories: ComponentFactory<any>[], _parent: ComponentFactoryResolver);
    resolveComponentFactory<T>(component: {
        new (...args: any[]): T;
    }): ComponentFactory<T>;
}
}
declare module '@angular/core/src/linker/component_factory_resolver' {
export * from '~@angular/core/src/linker/component_factory_resolver';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/ng_module_factory.d.ts
declare module '~@angular/core/src/linker/ng_module_factory' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di/injector';
import { Type } from '~@angular/core/src/type';
import { ComponentFactory } from '~@angular/core/src/linker/component_factory';
import { CodegenComponentFactoryResolver, ComponentFactoryResolver } from '~@angular/core/src/linker/component_factory_resolver';
/**
 * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
 *
 * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
 * NgModule Instance.
 *
 * @stable
 */
export abstract class NgModuleRef<T> {
    /**
     * The injector that contains all of the providers of the NgModule.
     */
    injector: Injector;
    /**
     * The ComponentFactoryResolver to get hold of the ComponentFactories
     * declared in the `entryComponents` property of the module.
     */
    componentFactoryResolver: ComponentFactoryResolver;
    /**
     * The NgModule instance.
     */
    instance: T;
    /**
     * Destroys the module instance and all of the data structures associated with it.
     */
    abstract destroy(): void;
    /**
     * Allows to register a callback that will be called when the module is destroyed.
     */
    abstract onDestroy(callback: () => void): void;
}
/**
 * @experimental
 */
export class NgModuleFactory<T> {
    private _injectorClass;
    private _moduleType;
    constructor(_injectorClass: {
        new (parentInjector: Injector): NgModuleInjector<T>;
    }, _moduleType: Type<T>);
    moduleType: Type<T>;
    create(parentInjector: Injector): NgModuleRef<T>;
}
export abstract class NgModuleInjector<T> extends CodegenComponentFactoryResolver implements Injector, NgModuleRef<T> {
    parent: Injector;
    bootstrapFactories: ComponentFactory<any>[];
    private _destroyListeners;
    private _destroyed;
    instance: T;
    constructor(parent: Injector, factories: ComponentFactory<any>[], bootstrapFactories: ComponentFactory<any>[]);
    create(): void;
    abstract createInternal(): T;
    get(token: any, notFoundValue?: any): any;
    abstract getInternal(token: any, notFoundValue: any): any;
    injector: Injector;
    componentFactoryResolver: ComponentFactoryResolver;
    destroy(): void;
    onDestroy(callback: () => void): void;
    abstract destroyInternal(): void;
}
}
declare module '@angular/core/src/linker/ng_module_factory' {
export * from '~@angular/core/src/linker/ng_module_factory';
}

// Generated by typings
// Source: node_modules/@angular/core/src/zone/ng_zone.d.ts
declare module '~@angular/core/src/zone/ng_zone' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { EventEmitter } from '~@angular/core/src/facade/async';
/**
 * An injectable service for executing work inside or outside of the Angular zone.
 *
 * The most common use of this service is to optimize performance when starting a work consisting of
 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
 * Angular. Such tasks can be kicked off via {@link runOutsideAngular} and if needed, these tasks
 * can reenter the Angular zone via {@link run}.
 *
 * <!-- TODO: add/fix links to:
 *   - docs explaining zones and the use of zones in Angular and change-detection
 *   - link to runOutsideAngular/run (throughout this file!)
 *   -->
 *
 * ### Example
 * ```
 * import {Component, NgZone} from '@angular/core';
 * import {NgIf} from '@angular/common';
 *
 * @Component({
 *   selector: 'ng-zone-demo'.
 *   template: `
 *     <h2>Demo: NgZone</h2>
 *
 *     <p>Progress: {{progress}}%</p>
 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
 *
 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
 *   `,
 * })
 * export class NgZoneDemo {
 *   progress: number = 0;
 *   label: string;
 *
 *   constructor(private _ngZone: NgZone) {}
 *
 *   // Loop inside the Angular zone
 *   // so the UI DOES refresh after each setTimeout cycle
 *   processWithinAngularZone() {
 *     this.label = 'inside';
 *     this.progress = 0;
 *     this._increaseProgress(() => console.log('Inside Done!'));
 *   }
 *
 *   // Loop outside of the Angular zone
 *   // so the UI DOES NOT refresh after each setTimeout cycle
 *   processOutsideOfAngularZone() {
 *     this.label = 'outside';
 *     this.progress = 0;
 *     this._ngZone.runOutsideAngular(() => {
 *       this._increaseProgress(() => {
 *       // reenter the Angular zone and display done
 *       this._ngZone.run(() => {console.log('Outside Done!') });
 *     }}));
 *   }
 *
 *   _increaseProgress(doneCallback: () => void) {
 *     this.progress += 1;
 *     console.log(`Current progress: ${this.progress}%`);
 *
 *     if (this.progress < 100) {
 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
 *     } else {
 *       doneCallback();
 *     }
 *   }
 * }
 * ```
 * @experimental
 */
export class NgZone {
    private outer;
    private inner;
    private _hasPendingMicrotasks;
    private _hasPendingMacrotasks;
    private _isStable;
    private _nesting;
    private _onUnstable;
    private _onMicrotaskEmpty;
    private _onStable;
    private _onErrorEvents;
    constructor({enableLongStackTrace}: {
        enableLongStackTrace?: boolean;
    });
    static isInAngularZone(): boolean;
    static assertInAngularZone(): void;
    static assertNotInAngularZone(): void;
    /**
     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
     * the function.
     *
     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
     * outside of the Angular zone (typically started via {@link runOutsideAngular}).
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * within the Angular zone.
     *
     * If a synchronous error happens it will be rethrown and not reported via `onError`.
     */
    run(fn: () => any): any;
    /**
     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
     * rethrown.
     */
    runGuarded(fn: () => any): any;
    /**
     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
     * the function.
     *
     * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * outside of the Angular zone.
     *
     * Use {@link run} to reenter the Angular zone and do work that updates the application model.
     */
    runOutsideAngular(fn: () => any): any;
    /**
     * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
     */
    onUnstable: EventEmitter<any>;
    /**
     * Notifies when there is no more microtasks enqueue in the current VM Turn.
     * This is a hint for Angular to do change detection, which may enqueue more microtasks.
     * For this reason this event can fire multiple times per VM Turn.
     */
    onMicrotaskEmpty: EventEmitter<any>;
    /**
     * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
     * implies we are about to relinquish VM turn.
     * This event gets called just once.
     */
    onStable: EventEmitter<any>;
    /**
     * Notify that an error has been delivered.
     */
    onError: EventEmitter<any>;
    /**
     * Whether there are no outstanding microtasks or macrotasks.
     */
    isStable: boolean;
    hasPendingMicrotasks: boolean;
    hasPendingMacrotasks: boolean;
    private checkStable();
    private forkInnerZoneWithAngularBehavior();
    private onEnter();
    private onLeave();
    private setHasMicrotask(hasMicrotasks);
    private setHasMacrotask(hasMacrotasks);
    private triggerError(error);
}
}
declare module '@angular/core/src/zone/ng_zone' {
export * from '~@angular/core/src/zone/ng_zone';
}

// Generated by typings
// Source: node_modules/@angular/core/src/application_ref.d.ts
declare module '~@angular/core/src/application_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ErrorHandler } from '~@angular/core/src/error_handler';
import { ApplicationInitStatus } from '~@angular/core/src/application_init';
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
import { Console } from '~@angular/core/src/console';
import { Injector, Provider } from '~@angular/core/src/di';
import { CompilerOptions } from '~@angular/core/src/linker/compiler';
import { ComponentFactory, ComponentRef } from '~@angular/core/src/linker/component_factory';
import { ComponentFactoryResolver } from '~@angular/core/src/linker/component_factory_resolver';
import { NgModuleFactory, NgModuleRef } from '~@angular/core/src/linker/ng_module_factory';
import { Testability, TestabilityRegistry } from '~@angular/core/src/testability/testability';
import { Type } from '~@angular/core/src/type';
import { NgZone } from '~@angular/core/src/zone/ng_zone';
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 *
 * @stable
 */
export function enableProdMode(): void;
/**
 * Returns whether Angular is in development mode. After called once,
 * the value is locked and won't change any more.
 *
 * By default, this is true, unless a user calls `enableProdMode` before calling this.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function isDevMode(): boolean;
/**
 * Creates a platform.
 * Platforms have to be eagerly created via this function.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function createPlatform(injector: Injector): PlatformRef;
/**
 * Creates a factory for a platform
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function createPlatformFactory(parentPlaformFactory: (extraProviders?: Provider[]) => PlatformRef, name: string, providers?: Provider[]): (extraProviders?: Provider[]) => PlatformRef;
/**
 * Checks that there currently is a platform
 * which contains the given token as a provider.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function assertPlatform(requiredToken: any): PlatformRef;
/**
 * Destroy the existing platform.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function destroyPlatform(): void;
/**
 * Returns the current platform.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function getPlatform(): PlatformRef;
/**
 * The Angular platform is the entry point for Angular on a web page. Each page
 * has exactly one platform, and services (such as reflection) which are common
 * to every Angular application running on the page are bound in its scope.
 *
 * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
 * explicitly by calling {@link createPlatform}().
 *
 * @stable
 */
export abstract class PlatformRef {
    /**
     * Creates an instance of an `@NgModule` for the given platform
     * for offline compilation.
     *
     * ## Simple Example
     *
     * ```typescript
     * my_module.ts:
     *
     * @NgModule({
     *   imports: [BrowserModule]
     * })
     * class MyModule {}
     *
     * main.ts:
     * import {MyModuleNgFactory} from './my_module.ngfactory';
     * import {platformBrowser} from '@angular/platform-browser';
     *
     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
     * ```
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>): Promise<NgModuleRef<M>>;
    /**
     * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
     *
     * ## Simple Example
     *
     * ```typescript
     * @NgModule({
     *   imports: [BrowserModule]
     * })
     * class MyModule {}
     *
     * let moduleRef = platformBrowser().bootstrapModule(MyModule);
     * ```
     * @stable
     */
    bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: CompilerOptions | CompilerOptions[]): Promise<NgModuleRef<M>>;
    /**
     * Register a listener to be called when the platform is disposed.
     */
    abstract onDestroy(callback: () => void): void;
    /**
     * Retrieve the platform {@link Injector}, which is the parent injector for
     * every Angular application on the page and provides singleton providers.
     */
    injector: Injector;
    /**
     * Destroy the Angular platform and all Angular applications on the page.
     */
    abstract destroy(): void;
    destroyed: boolean;
}
export class PlatformRef_ extends PlatformRef {
    private _injector;
    private _modules;
    private _destroyListeners;
    private _destroyed;
    constructor(_injector: Injector);
    onDestroy(callback: () => void): void;
    injector: Injector;
    destroyed: boolean;
    destroy(): void;
    bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>): Promise<NgModuleRef<M>>;
    private _bootstrapModuleFactoryWithZone<M>(moduleFactory, ngZone);
    bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: CompilerOptions | CompilerOptions[]): Promise<NgModuleRef<M>>;
    private _bootstrapModuleWithZone<M>(moduleType, compilerOptions, ngZone, componentFactoryCallback?);
    private _moduleDoBootstrap(moduleRef);
}
/**
 * A reference to an Angular application running on a page.
 *
 * For more about Angular applications, see the documentation for {@link bootstrap}.
 *
 * @stable
 */
export abstract class ApplicationRef {
    /**
     * Bootstrap a new component at the root level of the application.
     *
     * ### Bootstrap process
     *
     * When bootstrapping a new root component into an application, Angular mounts the
     * specified application component onto DOM elements identified by the [componentType]'s
     * selector and kicks off automatic change detection to finish initializing the component.
     *
     * ### Example
     * {@example core/ts/platform/platform.ts region='longform'}
     */
    abstract bootstrap<C>(componentFactory: ComponentFactory<C> | Type<C>): ComponentRef<C>;
    /**
     * Invoke this method to explicitly process change detection and its side-effects.
     *
     * In development mode, `tick()` also performs a second change detection cycle to ensure that no
     * further changes are detected. If additional changes are picked up during this second cycle,
     * bindings in the app have side-effects that cannot be resolved in a single change detection
     * pass.
     * In this case, Angular throws an error, since an Angular application can only have one change
     * detection pass during which all change detection must complete.
     */
    abstract tick(): void;
    /**
     * Get a list of component types registered to this application.
     * This list is populated even before the component is created.
     */
    componentTypes: Type<any>[];
    /**
     * Get a list of components registered to this application.
     */
    components: ComponentRef<any>[];
}
export class ApplicationRef_ extends ApplicationRef {
    private _zone;
    private _console;
    private _injector;
    private _exceptionHandler;
    private _componentFactoryResolver;
    private _initStatus;
    private _testabilityRegistry;
    private _testability;
    private _bootstrapListeners;
    private _rootComponents;
    private _rootComponentTypes;
    private _changeDetectorRefs;
    private _runningTick;
    private _enforceNoNewChanges;
    constructor(_zone: NgZone, _console: Console, _injector: Injector, _exceptionHandler: ErrorHandler, _componentFactoryResolver: ComponentFactoryResolver, _initStatus: ApplicationInitStatus, _testabilityRegistry: TestabilityRegistry, _testability: Testability);
    registerChangeDetector(changeDetector: ChangeDetectorRef): void;
    unregisterChangeDetector(changeDetector: ChangeDetectorRef): void;
    bootstrap<C>(componentOrFactory: ComponentFactory<C> | Type<C>): ComponentRef<C>;
    tick(): void;
    ngOnDestroy(): void;
    componentTypes: Type<any>[];
    components: ComponentRef<any>[];
}
}
declare module '@angular/core/src/application_ref' {
export * from '~@angular/core/src/application_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/application_tokens.d.ts
declare module '~@angular/core/src/application_tokens' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { OpaqueToken } from '~@angular/core/src/di';
/**
 * A DI Token representing a unique string id assigned to the application by Angular and used
 * primarily for prefixing application attributes and CSS styles when
 * {@link ViewEncapsulation#Emulated} is being used.
 *
 * If you need to avoid randomly generated value to be used as an application id, you can provide
 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
 * using this token.
 * @experimental
 */
export const APP_ID: any;
export function _appIdRandomProviderFactory(): string;
/**
 * Providers that will generate a random APP_ID_TOKEN.
 * @experimental
 */
export const APP_ID_RANDOM_PROVIDER: {
    provide: any;
    useFactory: () => string;
    deps: any[];
};
/**
 * A function that will be executed when a platform is initialized.
 * @experimental
 */
export const PLATFORM_INITIALIZER: any;
/**
 * All callbacks provided via this token will be called for every component that is bootstrapped.
 * Signature of the callback:
 *
 * `(componentRef: ComponentRef) => void`.
 *
 * @experimental
 */
export const APP_BOOTSTRAP_LISTENER: OpaqueToken;
/**
 * A token which indicates the root directory of the application
 * @experimental
 */
export const PACKAGE_ROOT_URL: any;
}
declare module '@angular/core/src/application_tokens' {
export * from '~@angular/core/src/application_tokens';
}

// Generated by typings
// Source: node_modules/@angular/core/src/application_init.d.ts
declare module '~@angular/core/src/application_init' {
/**
 * A function that will be executed when an application is initialized.
 * @experimental
 */
export const APP_INITIALIZER: any;
/**
 * A class that reflects the state of running {@link APP_INITIALIZER}s.
 *
 * @experimental
 */
export class ApplicationInitStatus {
    private _donePromise;
    private _done;
    constructor(appInits: (() => any)[]);
    done: boolean;
    donePromise: Promise<any>;
}
}
declare module '@angular/core/src/application_init' {
export * from '~@angular/core/src/application_init';
}

// Generated by typings
// Source: node_modules/@angular/core/src/zone.d.ts
declare module '~@angular/core/src/zone' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { NgZone } from '~@angular/core/src/zone/ng_zone';
}
declare module '@angular/core/src/zone' {
export * from '~@angular/core/src/zone';
}

// Generated by typings
// Source: node_modules/@angular/core/src/render/api.d.ts
declare module '~@angular/core/src/render/api' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationKeyframe } from '~@angular/core/src/animation/animation_keyframe';
import { AnimationPlayer } from '~@angular/core/src/animation/animation_player';
import { AnimationStyles } from '~@angular/core/src/animation/animation_styles';
import { Injector } from '~@angular/core/src/di/injector';
import { ViewEncapsulation } from '~@angular/core/src/metadata/view';
/**
 * @experimental
 */
export class RenderComponentType {
    id: string;
    templateUrl: string;
    slotCount: number;
    encapsulation: ViewEncapsulation;
    styles: Array<string | any[]>;
    animations: {
        [key: string]: Function;
    };
    constructor(id: string, templateUrl: string, slotCount: number, encapsulation: ViewEncapsulation, styles: Array<string | any[]>, animations: {
        [key: string]: Function;
    });
}
export abstract class RenderDebugInfo {
    injector: Injector;
    component: any;
    providerTokens: any[];
    references: {
        [key: string]: any;
    };
    context: any;
    source: string;
}
/**
 * @experimental
 */
export abstract class Renderer {
    abstract selectRootElement(selectorOrNode: string | any, debugInfo?: RenderDebugInfo): any;
    abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;
    abstract createViewRoot(hostElement: any): any;
    abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;
    abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;
    abstract projectNodes(parentElement: any, nodes: any[]): void;
    abstract attachViewAfter(node: any, viewRootNodes: any[]): void;
    abstract detachView(viewRootNodes: any[]): void;
    abstract destroyView(hostElement: any, viewAllNodes: any[]): void;
    abstract listen(renderElement: any, name: string, callback: Function): Function;
    abstract listenGlobal(target: string, name: string, callback: Function): Function;
    abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;
    abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue: string): void;
    /**
     * Used only in debug mode to serialize property changes to dom nodes as attributes.
     */
    abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string): void;
    abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;
    abstract setElementStyle(renderElement: any, styleName: string, styleValue: string): void;
    abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;
    abstract setText(renderNode: any, text: string): void;
    abstract animate(element: any, startingStyles: AnimationStyles, keyframes: AnimationKeyframe[], duration: number, delay: number, easing: string): AnimationPlayer;
}
/**
 * Injectable service that provides a low-level interface for modifying the UI.
 *
 * Use this service to bypass Angular's templating and make custom UI changes that can't be
 * expressed declaratively. For example if you need to set a property or an attribute whose name is
 * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
 * respectively.
 *
 * If you are implementing a custom renderer, you must implement this interface.
 *
 * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
 * @experimental
 */
export abstract class RootRenderer {
    abstract renderComponent(componentType: RenderComponentType): Renderer;
}
}
declare module '@angular/core/src/render/api' {
export * from '~@angular/core/src/render/api';
}

// Generated by typings
// Source: node_modules/@angular/core/src/render.d.ts
declare module '~@angular/core/src/render' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { RenderComponentType, Renderer, RootRenderer } from '~@angular/core/src/render/api';
}
declare module '@angular/core/src/render' {
export * from '~@angular/core/src/render';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/element_ref.d.ts
declare module '~@angular/core/src/linker/element_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A wrapper around a native element inside of a View.
 *
 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
 * element.
 *
 * @security Permitting direct access to the DOM can make your application more vulnerable to
 * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
 * [Security Guide](http://g.co/ng/security).
 *
 * @stable
 */
export class ElementRef {
    /**
     * The underlying native element or `null` if direct access to native elements is not supported
     * (e.g. when the application runs in a web worker).
     *
     * <div class="callout is-critical">
     *   <header>Use with caution</header>
     *   <p>
     *    Use this API as the last resort when direct access to DOM is needed. Use templating and
     *    data-binding provided by Angular instead. Alternatively you take a look at {@link Renderer}
     *    which provides API that can safely be used even when direct access to native elements is not
     *    supported.
     *   </p>
     *   <p>
     *    Relying on direct DOM access creates tight coupling between your application and rendering
     *    layers which will make it impossible to separate the two and deploy your application into a
     *    web worker.
     *   </p>
     * </div>
     * @stable
     */
    nativeElement: any;
    constructor(nativeElement: any);
}
}
declare module '@angular/core/src/linker/element_ref' {
export * from '~@angular/core/src/linker/element_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/ng_module_factory_loader.d.ts
declare module '~@angular/core/src/linker/ng_module_factory_loader' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NgModuleFactory } from '~@angular/core/src/linker/ng_module_factory';
/**
 * Used to load ng module factories.
 * @stable
 */
export abstract class NgModuleFactoryLoader {
    abstract load(path: string): Promise<NgModuleFactory<any>>;
}
/**
 * Registers a loaded module. Should only be called from generated NgModuleFactory code.
 * @experimental
 */
export function registerModuleFactory(id: string, factory: NgModuleFactory<any>): void;
export function clearModulesForTest(): void;
/**
 * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
 * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
 * cannot be found.
 * @experimental
 */
export function getModuleFactory(id: string): NgModuleFactory<any>;
}
declare module '@angular/core/src/linker/ng_module_factory_loader' {
export * from '~@angular/core/src/linker/ng_module_factory_loader';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/query_list.d.ts
declare module '~@angular/core/src/linker/query_list' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Observable } from '~@angular/core/src/facade/async';
/**
 * An unmodifiable list of items that Angular keeps up to date when the state
 * of the application changes.
 *
 * The type of object that {@link Query} and {@link ViewQueryMetadata} provide.
 *
 * Implements an iterable interface, therefore it can be used in both ES6
 * javascript `for (var i of items)` loops as well as in Angular templates with
 * `*ngFor="let i of myList"`.
 *
 * Changes can be observed by subscribing to the changes `Observable`.
 *
 * NOTE: In the future this class will implement an `Observable` interface.
 *
 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
 * ```typescript
 * @Component({...})
 * class Container {
 *   @ViewChildren(Item) items:QueryList<Item>;
 * }
 * ```
 * @stable
 */
export class QueryList<T> {
    private _dirty;
    private _results;
    private _emitter;
    changes: Observable<any>;
    length: number;
    first: T;
    last: T;
    /**
     * See
     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
     */
    map<U>(fn: (item: T, index: number, array: T[]) => U): U[];
    /**
     * See
     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
     */
    filter(fn: (item: T, index: number, array: T[]) => boolean): T[];
    /**
     * See
     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
     */
    reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;
    /**
     * See
     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
     */
    forEach(fn: (item: T, index: number, array: T[]) => void): void;
    /**
     * See
     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
     */
    some(fn: (value: T, index: number, array: T[]) => boolean): boolean;
    toArray(): T[];
    toString(): string;
    reset(res: Array<T | any[]>): void;
    notifyOnChanges(): void;
    /** internal */
    setDirty(): void;
    /** internal */
    dirty: boolean;
}
}
declare module '@angular/core/src/linker/query_list' {
export * from '~@angular/core/src/linker/query_list';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/system_js_ng_module_factory_loader.d.ts
declare module '~@angular/core/src/linker/system_js_ng_module_factory_loader' {
import { Compiler } from '~@angular/core/src/linker/compiler';
import { NgModuleFactory } from '~@angular/core/src/linker/ng_module_factory';
import { NgModuleFactoryLoader } from '~@angular/core/src/linker/ng_module_factory_loader';
/**
 * Configuration for SystemJsNgModuleLoader.
 * token.
 *
 * @experimental
 */
export abstract class SystemJsNgModuleLoaderConfig {
    /**
     * Prefix to add when computing the name of the factory module for a given module name.
     */
    factoryPathPrefix: string;
    /**
     * Suffix to add when computing the name of the factory module for a given module name.
     */
    factoryPathSuffix: string;
}
/**
 * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
 * @experimental
 */
export class SystemJsNgModuleLoader implements NgModuleFactoryLoader {
    private _compiler;
    private _config;
    constructor(_compiler: Compiler, config?: SystemJsNgModuleLoaderConfig);
    load(path: string): Promise<NgModuleFactory<any>>;
    private loadAndCompile(path);
    private loadFactory(path);
}
}
declare module '@angular/core/src/linker/system_js_ng_module_factory_loader' {
export * from '~@angular/core/src/linker/system_js_ng_module_factory_loader';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/template_ref.d.ts
declare module '~@angular/core/src/linker/template_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AppElement } from '~@angular/core/src/linker/element';
import { ElementRef } from '~@angular/core/src/linker/element_ref';
import { EmbeddedViewRef } from '~@angular/core/src/linker/view_ref';
/**
 * Represents an Embedded Template that can be used to instantiate Embedded Views.
 *
 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
 * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
 * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
 * `TemplateRef` from a Component or a Directive via {@link Query}.
 *
 * To instantiate Embedded Views based on a Template, use
 * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
 * View Container.
 * @stable
 */
export abstract class TemplateRef<C> {
    /**
     * The location in the View where the Embedded View logically belongs to.
     *
     * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
     * inherit from the contexts of this location.
     *
     * Typically new Embedded Views are attached to the View Container of this location, but in
     * advanced use-cases, the View can be attached to a different container while keeping the
     * data-binding and injection context from the original location.
     *
     */
    elementRef: ElementRef;
    abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;
}
export class TemplateRef_<C> extends TemplateRef<C> {
    private _appElement;
    private _viewFactory;
    constructor(_appElement: AppElement, _viewFactory: Function);
    createEmbeddedView(context: C): EmbeddedViewRef<C>;
    elementRef: ElementRef;
}
}
declare module '@angular/core/src/linker/template_ref' {
export * from '~@angular/core/src/linker/template_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/view_container_ref.d.ts
declare module '~@angular/core/src/linker/view_container_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di/injector';
import { ComponentFactory, ComponentRef } from '~@angular/core/src/linker/component_factory';
import { AppElement } from '~@angular/core/src/linker/element';
import { ElementRef } from '~@angular/core/src/linker/element_ref';
import { TemplateRef } from '~@angular/core/src/linker/template_ref';
import { EmbeddedViewRef, ViewRef } from '~@angular/core/src/linker/view_ref';
/**
 * Represents a container where one or more Views can be attached.
 *
 * The container can contain two kinds of Views. Host Views, created by instantiating a
 * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
 * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
 *
 * The location of the View Container within the containing View is specified by the Anchor
 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
 * have a single View Container.
 *
 * Root elements of Views attached to this container become siblings of the Anchor Element in
 * the Rendered View.
 *
 * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
 * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
 * @stable
 */
export abstract class ViewContainerRef {
    /**
     * Anchor element that specifies the location of this container in the containing View.
     * <!-- TODO: rename to anchorElement -->
     */
    element: ElementRef;
    injector: Injector;
    parentInjector: Injector;
    /**
     * Destroys all Views in this container.
     */
    abstract clear(): void;
    /**
     * Returns the {@link ViewRef} for the View located in this container at the specified index.
     */
    abstract get(index: number): ViewRef;
    /**
     * Returns the number of Views currently attached to this container.
     */
    length: number;
    /**
     * Instantiates an Embedded View based on the {@link TemplateRef `templateRef`} and inserts it
     * into this container at the specified `index`.
     *
     * If `index` is not specified, the new View will be inserted as the last View in the container.
     *
     * Returns the {@link ViewRef} for the newly created View.
     */
    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;
    /**
     * Instantiates a single {@link Component} and inserts its Host View into this container at the
     * specified `index`.
     *
     * The component is instantiated using its {@link ComponentFactory} which can be
     * obtained via {@link ComponentFactoryResolver#resolveComponentFactory}.
     *
     * If `index` is not specified, the new View will be inserted as the last View in the container.
     *
     * You can optionally specify the {@link Injector} that will be used as parent for the Component.
     *
     * Returns the {@link ComponentRef} of the Host View created for the newly instantiated Component.
     */
    abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][]): ComponentRef<C>;
    /**
     * Inserts a View identified by a {@link ViewRef} into the container at the specified `index`.
     *
     * If `index` is not specified, the new View will be inserted as the last View in the container.
     *
     * Returns the inserted {@link ViewRef}.
     */
    abstract insert(viewRef: ViewRef, index?: number): ViewRef;
    /**
     * Moves a View identified by a {@link ViewRef} into the container at the specified `index`.
     *
     * Returns the inserted {@link ViewRef}.
     */
    abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;
    /**
     * Returns the index of the View, specified via {@link ViewRef}, within the current container or
     * `-1` if this container doesn't contain the View.
     */
    abstract indexOf(viewRef: ViewRef): number;
    /**
     * Destroys a View attached to this container at the specified `index`.
     *
     * If `index` is not specified, the last View in the container will be removed.
     */
    abstract remove(index?: number): void;
    /**
     * Use along with {@link #insert} to move a View within the current container.
     *
     * If the `index` param is omitted, the last {@link ViewRef} is detached.
     */
    abstract detach(index?: number): ViewRef;
}
export class ViewContainerRef_ implements ViewContainerRef {
    private _element;
    constructor(_element: AppElement);
    get(index: number): ViewRef;
    length: number;
    element: ElementRef;
    injector: Injector;
    parentInjector: Injector;
    createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;
    createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][]): ComponentRef<C>;
    insert(viewRef: ViewRef, index?: number): ViewRef;
    move(viewRef: ViewRef, currentIndex: number): ViewRef;
    indexOf(viewRef: ViewRef): number;
    remove(index?: number): void;
    detach(index?: number): ViewRef;
    clear(): void;
}
}
declare module '@angular/core/src/linker/view_container_ref' {
export * from '~@angular/core/src/linker/view_container_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/view_ref.d.ts
declare module '~@angular/core/src/linker/view_ref' {
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
import { AppView } from '~@angular/core/src/linker/view';
/**
 * @stable
 */
export abstract class ViewRef {
    destroyed: boolean;
    abstract onDestroy(callback: Function): any;
}
/**
 * Represents an Angular View.
 *
 * <!-- TODO: move the next two paragraphs to the dev guide -->
 * A View is a fundamental building block of the application UI. It is the smallest grouping of
 * Elements which are created and destroyed together.
 *
 * Properties of elements in a View can change, but the structure (number and order) of elements in
 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
 * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
 * <!-- /TODO -->
 *
 * ### Example
 *
 * Given this template...
 *
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <li *ngFor="let  item of items">{{item}}</li>
 * </ul>
 * ```
 *
 * We have two {@link TemplateRef}s:
 *
 * Outer {@link TemplateRef}:
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <template ngFor let-item [ngForOf]="items"></template>
 * </ul>
 * ```
 *
 * Inner {@link TemplateRef}:
 * ```
 *   <li>{{item}}</li>
 * ```
 *
 * Notice that the original template is broken down into two separate {@link TemplateRef}s.
 *
 * The outer/inner {@link TemplateRef}s are then assembled into views like so:
 *
 * ```
 * <!-- ViewRef: outer-0 -->
 * Count: 2
 * <ul>
 *   <template view-container-ref></template>
 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
 * </ul>
 * <!-- /ViewRef: outer-0 -->
 * ```
 * @experimental
 */
export abstract class EmbeddedViewRef<C> extends ViewRef {
    context: C;
    rootNodes: any[];
    /**
     * Destroys the view and all of the data structures associated with it.
     */
    abstract destroy(): void;
}
export class ViewRef_<C> implements EmbeddedViewRef<C>, ChangeDetectorRef {
    private _view;
    constructor(_view: AppView<C>);
    internalView: AppView<C>;
    rootNodes: any[];
    context: C;
    destroyed: boolean;
    markForCheck(): void;
    detach(): void;
    detectChanges(): void;
    checkNoChanges(): void;
    reattach(): void;
    onDestroy(callback: Function): void;
    destroy(): void;
}
}
declare module '@angular/core/src/linker/view_ref' {
export * from '~@angular/core/src/linker/view_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker.d.ts
declare module '~@angular/core/src/linker' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { COMPILER_OPTIONS, Compiler, CompilerFactory, CompilerOptions, ModuleWithComponentFactories } from '~@angular/core/src/linker/compiler';
export { ComponentFactory, ComponentRef } from '~@angular/core/src/linker/component_factory';
export { ComponentFactoryResolver } from '~@angular/core/src/linker/component_factory_resolver';
export { ElementRef } from '~@angular/core/src/linker/element_ref';
export { NgModuleFactory, NgModuleRef } from '~@angular/core/src/linker/ng_module_factory';
export { NgModuleFactoryLoader, getModuleFactory } from '~@angular/core/src/linker/ng_module_factory_loader';
export { QueryList } from '~@angular/core/src/linker/query_list';
export { SystemJsNgModuleLoader, SystemJsNgModuleLoaderConfig } from '~@angular/core/src/linker/system_js_ng_module_factory_loader';
export { TemplateRef } from '~@angular/core/src/linker/template_ref';
export { ViewContainerRef } from '~@angular/core/src/linker/view_container_ref';
export { EmbeddedViewRef, ViewRef } from '~@angular/core/src/linker/view_ref';
}
declare module '@angular/core/src/linker' {
export * from '~@angular/core/src/linker';
}

// Generated by typings
// Source: node_modules/@angular/core/src/facade/collection.d.ts
declare module '~@angular/core/src/facade/collection' {
export class MapWrapper {
    static createFromStringMap<T>(stringMap: {
        [key: string]: T;
    }): Map<string, T>;
    static keys<K>(m: Map<K, any>): K[];
    static values<V>(m: Map<any, V>): V[];
}
/**
 * Wraps Javascript Objects
 */
export class StringMapWrapper {
    static merge<V>(m1: {
        [key: string]: V;
    }, m2: {
        [key: string]: V;
    }): {
        [key: string]: V;
    };
    static equals<V>(m1: {
        [key: string]: V;
    }, m2: {
        [key: string]: V;
    }): boolean;
}
/**
 * A boolean-valued function over a value, possibly including context information
 * regarding that value's position in an array.
 */
export interface Predicate<T> {
    (value: T, index?: number, array?: T[]): boolean;
}
export class ListWrapper {
    static removeAll<T>(list: T[], items: T[]): void;
    static remove<T>(list: T[], el: T): boolean;
    static equals(a: any[], b: any[]): boolean;
    static maximum<T>(list: T[], predicate: (t: T) => number): T;
    static flatten<T>(list: Array<T | T[]>): T[];
}
export function isListLikeIterable(obj: any): boolean;
export function areIterablesEqual(a: any, b: any, comparator: Function): boolean;
export function iterateListLike(obj: any, fn: Function): void;
}
declare module '@angular/core/src/facade/collection' {
export * from '~@angular/core/src/facade/collection';
}

// Generated by typings
// Source: node_modules/@angular/core/src/debug/debug_node.d.ts
declare module '~@angular/core/src/debug/debug_node' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di';
import { Predicate } from '~@angular/core/src/facade/collection';
import { RenderDebugInfo } from '~@angular/core/src/render/api';
export class EventListener {
    name: string;
    callback: Function;
    constructor(name: string, callback: Function);
}
/**
 * @experimental All debugging apis are currently experimental.
 */
export class DebugNode {
    private _debugInfo;
    nativeNode: any;
    listeners: EventListener[];
    parent: DebugElement;
    constructor(nativeNode: any, parent: DebugNode, _debugInfo: RenderDebugInfo);
    injector: Injector;
    componentInstance: any;
    context: any;
    references: {
        [key: string]: any;
    };
    providerTokens: any[];
    source: string;
}
/**
 * @experimental All debugging apis are currently experimental.
 */
export class DebugElement extends DebugNode {
    name: string;
    properties: {
        [key: string]: any;
    };
    attributes: {
        [key: string]: string;
    };
    classes: {
        [key: string]: boolean;
    };
    styles: {
        [key: string]: string;
    };
    childNodes: DebugNode[];
    nativeElement: any;
    constructor(nativeNode: any, parent: any, _debugInfo: RenderDebugInfo);
    addChild(child: DebugNode): void;
    removeChild(child: DebugNode): void;
    insertChildrenAfter(child: DebugNode, newChildren: DebugNode[]): void;
    query(predicate: Predicate<DebugElement>): DebugElement;
    queryAll(predicate: Predicate<DebugElement>): DebugElement[];
    queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];
    children: DebugElement[];
    triggerEventHandler(eventName: string, eventObj: any): void;
}
/**
 * @experimental
 */
export function asNativeElements(debugEls: DebugElement[]): any;
/**
 * @experimental
 */
export function getDebugNode(nativeNode: any): DebugNode;
export function getAllDebugNodes(): DebugNode[];
export function indexDebugNode(node: DebugNode): void;
export function removeDebugNodeFromIndex(node: DebugNode): void;
}
declare module '@angular/core/src/debug/debug_node' {
export * from '~@angular/core/src/debug/debug_node';
}

// Generated by typings
// Source: node_modules/@angular/core/src/testability/testability.d.ts
declare module '~@angular/core/src/testability/testability' {
import { NgZone } from '~@angular/core/src/zone/ng_zone';
/**
 * Testability API.
 * `declare` keyword causes tsickle to generate externs, so these methods are
 * not renamed by Closure Compiler.
 * @experimental
 */
export interface PublicTestability {
    isStable(): boolean;
    whenStable(callback: Function): void;
    findProviders(using: any, provider: string, exactMatch: boolean): any[];
}
/**
 * The Testability service provides testing hooks that can be accessed from
 * the browser and by services such as Protractor. Each bootstrapped Angular
 * application on the page will have an instance of Testability.
 * @experimental
 */
export class Testability implements PublicTestability {
    private _ngZone;
    constructor(_ngZone: NgZone);
    increasePendingRequestCount(): number;
    decreasePendingRequestCount(): number;
    isStable(): boolean;
    whenStable(callback: Function): void;
    getPendingRequestCount(): number;
    /** @deprecated use findProviders */
    findBindings(using: any, provider: string, exactMatch: boolean): any[];
    findProviders(using: any, provider: string, exactMatch: boolean): any[];
}
/**
 * A global registry of {@link Testability} instances for specific elements.
 * @experimental
 */
export class TestabilityRegistry {
    constructor();
    registerApplication(token: any, testability: Testability): void;
    getTestability(elem: any): Testability;
    getAllTestabilities(): Testability[];
    getAllRootElements(): any[];
    findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability;
}
/**
 * Adapter interface for retrieving the `Testability` service associated for a
 * particular context.
 *
 * @experimental Testability apis are primarily intended to be used by e2e test tool vendors like
 * the Protractor team.
 */
export interface GetTestability {
    addToWindow(registry: TestabilityRegistry): void;
    findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability;
}
/**
 * Set the {@link GetTestability} implementation used by the Angular testing framework.
 * @experimental
 */
export function setTestabilityGetter(getter: GetTestability): void;
}
declare module '@angular/core/src/testability/testability' {
export * from '~@angular/core/src/testability/testability';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/differs/iterable_differs.d.ts
declare module '~@angular/core/src/change_detection/differs/iterable_differs' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Provider } from '~@angular/core/src/di';
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
/**
 * A strategy for tracking changes over time to an iterable. Used for {@link NgFor} to
 * respond to changes in an iterable by effecting equivalent changes in the DOM.
 *
 * @stable
 */
export interface IterableDiffer {
    diff(object: any): any;
    onDestroy(): any;
}
/**
 * An optional function passed into {@link NgFor} that defines how to track
 * items in an iterable (e.g. by index or id)
 *
 * @stable
 */
export interface TrackByFn {
    (index: number, item: any): any;
}
/**
 * Provides a factory for {@link IterableDiffer}.
 *
 * @stable
 */
export interface IterableDifferFactory {
    supports(objects: any): boolean;
    create(cdRef: ChangeDetectorRef, trackByFn?: TrackByFn): IterableDiffer;
}
/**
 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
 * @stable
 */
export class IterableDiffers {
    factories: IterableDifferFactory[];
    constructor(factories: IterableDifferFactory[]);
    static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;
    /**
     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
     * inherited {@link IterableDiffers} instance with the provided factories and return a new
     * {@link IterableDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link IterableDiffer} available.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     IterableDiffers.extend([new ImmutableListDiffer()])
     *   ]
     * })
     * ```
     */
    static extend(factories: IterableDifferFactory[]): Provider;
    find(iterable: any): IterableDifferFactory;
}
}
declare module '@angular/core/src/change_detection/differs/iterable_differs' {
export * from '~@angular/core/src/change_detection/differs/iterable_differs';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/differs/keyvalue_differs.d.ts
declare module '~@angular/core/src/change_detection/differs/keyvalue_differs' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Provider } from '~@angular/core/src/di';
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
/**
 * A differ that tracks changes made to an object over time.
 *
 * @stable
 */
export interface KeyValueDiffer {
    diff(object: any): any;
    onDestroy(): any;
}
/**
 * Provides a factory for {@link KeyValueDiffer}.
 *
 * @stable
 */
export interface KeyValueDifferFactory {
    supports(objects: any): boolean;
    create(cdRef: ChangeDetectorRef): KeyValueDiffer;
}
/**
 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
 * @stable
 */
export class KeyValueDiffers {
    factories: KeyValueDifferFactory[];
    constructor(factories: KeyValueDifferFactory[]);
    static create(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;
    /**
     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
     * {@link KeyValueDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link KeyValueDiffer} available.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
     *   ]
     * })
     * ```
     */
    static extend(factories: KeyValueDifferFactory[]): Provider;
    find(kv: Object): KeyValueDifferFactory;
}
}
declare module '@angular/core/src/change_detection/differs/keyvalue_differs' {
export * from '~@angular/core/src/change_detection/differs/keyvalue_differs';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/differs/default_iterable_differ.d.ts
declare module '~@angular/core/src/change_detection/differs/default_iterable_differ' {
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
import { IterableDiffer, IterableDifferFactory, TrackByFn } from '~@angular/core/src/change_detection/differs/iterable_differs';
export class DefaultIterableDifferFactory implements IterableDifferFactory {
    constructor();
    supports(obj: Object): boolean;
    create(cdRef: ChangeDetectorRef, trackByFn?: TrackByFn): DefaultIterableDiffer;
}
/**
 * @stable
 */
export class DefaultIterableDiffer implements IterableDiffer {
    private _trackByFn;
    private _length;
    private _collection;
    private _linkedRecords;
    private _unlinkedRecords;
    private _previousItHead;
    private _itHead;
    private _itTail;
    private _additionsHead;
    private _additionsTail;
    private _movesHead;
    private _movesTail;
    private _removalsHead;
    private _removalsTail;
    private _identityChangesHead;
    private _identityChangesTail;
    constructor(_trackByFn?: TrackByFn);
    collection: any;
    length: number;
    forEachItem(fn: Function): void;
    forEachOperation(fn: (item: CollectionChangeRecord, previousIndex: number, currentIndex: number) => void): void;
    forEachPreviousItem(fn: Function): void;
    forEachAddedItem(fn: Function): void;
    forEachMovedItem(fn: Function): void;
    forEachRemovedItem(fn: Function): void;
    forEachIdentityChange(fn: Function): void;
    diff(collection: any): DefaultIterableDiffer;
    onDestroy(): void;
    check(collection: any): boolean;
    isDirty: boolean;
    toString(): string;
}
/**
 * @stable
 */
export class CollectionChangeRecord {
    item: any;
    trackById: any;
    currentIndex: number;
    previousIndex: number;
    constructor(item: any, trackById: any);
    toString(): string;
}
}
declare module '@angular/core/src/change_detection/differs/default_iterable_differ' {
export * from '~@angular/core/src/change_detection/differs/default_iterable_differ';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/differs/default_keyvalue_differ.d.ts
declare module '~@angular/core/src/change_detection/differs/default_keyvalue_differ' {
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
import { KeyValueDiffer, KeyValueDifferFactory } from '~@angular/core/src/change_detection/differs/keyvalue_differs';
export class DefaultKeyValueDifferFactory implements KeyValueDifferFactory {
    constructor();
    supports(obj: any): boolean;
    create(cdRef: ChangeDetectorRef): KeyValueDiffer;
}
export class DefaultKeyValueDiffer implements KeyValueDiffer {
    private _records;
    private _mapHead;
    private _previousMapHead;
    private _changesHead;
    private _changesTail;
    private _additionsHead;
    private _additionsTail;
    private _removalsHead;
    private _removalsTail;
    isDirty: boolean;
    forEachItem(fn: (r: KeyValueChangeRecord) => void): void;
    forEachPreviousItem(fn: (r: KeyValueChangeRecord) => void): void;
    forEachChangedItem(fn: (r: KeyValueChangeRecord) => void): void;
    forEachAddedItem(fn: (r: KeyValueChangeRecord) => void): void;
    forEachRemovedItem(fn: (r: KeyValueChangeRecord) => void): void;
    diff(map: Map<any, any> | {
        [k: string]: any;
    }): any;
    onDestroy(): void;
    check(map: Map<any, any> | {
        [k: string]: any;
    }): boolean;
    private _maybeAddToChanges(record, newValue);
    toString(): string;
}
/**
 * @stable
 */
export class KeyValueChangeRecord {
    key: any;
    previousValue: any;
    currentValue: any;
    constructor(key: any);
    toString(): string;
}
}
declare module '@angular/core/src/change_detection/differs/default_keyvalue_differ' {
export * from '~@angular/core/src/change_detection/differs/default_keyvalue_differ';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/pipe_transform.d.ts
declare module '~@angular/core/src/change_detection/pipe_transform' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * To create a Pipe, you must implement this interface.
 *
 * Angular invokes the `transform` method with the value of a binding
 * as the first argument, and any parameters as the second argument in list form.
 *
 * ## Syntax
 *
 * `value | pipeName[:arg0[:arg1...]]`
 *
 * ### Example ([live demo](http://plnkr.co/edit/f5oyIked9M2cKzvZNKHV?p=preview))
 *
 * The `RepeatPipe` below repeats the value as many times as indicated by the first argument:
 *
 * ```
 * import {Pipe, PipeTransform} from '@angular/core';
 *
 * @Pipe({name: 'repeat'})
 * export class RepeatPipe implements PipeTransform {
 *   transform(value: any, times: number) {
 *     return value.repeat(times);
 *   }
 * }
 * ```
 *
 * Invoking `{{ 'ok' | repeat:3 }}` in a template produces `okokok`.
 *
 * @stable
 */
export interface PipeTransform {
    transform(value: any, ...args: any[]): any;
}
}
declare module '@angular/core/src/change_detection/pipe_transform' {
export * from '~@angular/core/src/change_detection/pipe_transform';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/change_detection.d.ts
declare module '~@angular/core/src/change_detection/change_detection' {
import { IterableDifferFactory, IterableDiffers } from '~@angular/core/src/change_detection/differs/iterable_differs';
import { KeyValueDifferFactory, KeyValueDiffers } from '~@angular/core/src/change_detection/differs/keyvalue_differs';
export { SimpleChanges } from '~@angular/core/src/metadata/lifecycle_hooks';
export { SimpleChange, UNINITIALIZED, ValueUnwrapper, WrappedValue, devModeEqual, looseIdentical } from '~@angular/core/src/change_detection/change_detection_util';
export { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
export { ChangeDetectionStrategy, ChangeDetectorStatus, isDefaultChangeDetectionStrategy } from '~@angular/core/src/change_detection/constants';
export { CollectionChangeRecord, DefaultIterableDifferFactory } from '~@angular/core/src/change_detection/differs/default_iterable_differ';
export { DefaultIterableDiffer } from '~@angular/core/src/change_detection/differs/default_iterable_differ';
export { DefaultKeyValueDifferFactory, KeyValueChangeRecord } from '~@angular/core/src/change_detection/differs/default_keyvalue_differ';
export { IterableDiffer, IterableDifferFactory, IterableDiffers, TrackByFn } from '~@angular/core/src/change_detection/differs/iterable_differs';
export { KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers } from '~@angular/core/src/change_detection/differs/keyvalue_differs';
export { PipeTransform } from '~@angular/core/src/change_detection/pipe_transform';
/**
 * Structural diffing for `Object`s and `Map`s.
 */
export const keyValDiff: KeyValueDifferFactory[];
/**
 * Structural diffing for `Iterable` types such as `Array`s.
 */
export const iterableDiff: IterableDifferFactory[];
export const defaultIterableDiffers: IterableDiffers;
export const defaultKeyValueDiffers: KeyValueDiffers;
}
declare module '@angular/core/src/change_detection/change_detection' {
export * from '~@angular/core/src/change_detection/change_detection';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection.d.ts
declare module '~@angular/core/src/change_detection' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Change detection enables data binding in Angular.
 */
export { ChangeDetectionStrategy, ChangeDetectorRef, CollectionChangeRecord, DefaultIterableDiffer, IterableDiffer, IterableDifferFactory, IterableDiffers, KeyValueChangeRecord, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers, PipeTransform, SimpleChange, SimpleChanges, TrackByFn, WrappedValue } from '~@angular/core/src/change_detection/change_detection';
}
declare module '@angular/core/src/change_detection' {
export * from '~@angular/core/src/change_detection';
}

// Generated by typings
// Source: node_modules/@angular/core/src/platform_core_providers.d.ts
declare module '~@angular/core/src/platform_core_providers' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { PlatformRef } from '~@angular/core/src/application_ref';
import { Provider } from '~@angular/core/src/di';
/**
 * This platform has to be included in any other platform
 *
 * @experimental
 */
export const platformCore: (extraProviders?: Provider[]) => PlatformRef;
}
declare module '@angular/core/src/platform_core_providers' {
export * from '~@angular/core/src/platform_core_providers';
}

// Generated by typings
// Source: node_modules/@angular/core/src/i18n/tokens.d.ts
declare module '~@angular/core/src/i18n/tokens' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { OpaqueToken } from '~@angular/core/src/di/opaque_token';
/**
 * @experimental i18n support is experimental.
 */
export const LOCALE_ID: OpaqueToken;
/**
 * @experimental i18n support is experimental.
 */
export const TRANSLATIONS: OpaqueToken;
/**
 * @experimental i18n support is experimental.
 */
export const TRANSLATIONS_FORMAT: OpaqueToken;
}
declare module '@angular/core/src/i18n/tokens' {
export * from '~@angular/core/src/i18n/tokens';
}

// Generated by typings
// Source: node_modules/@angular/core/src/application_module.d.ts
declare module '~@angular/core/src/application_module' {
import { IterableDiffers, KeyValueDiffers } from '~@angular/core/src/change_detection/change_detection';
export function _iterableDiffersFactory(): IterableDiffers;
export function _keyValueDiffersFactory(): KeyValueDiffers;
/**
 * This module includes the providers of @angular/core that are needed
 * to bootstrap components via `ApplicationRef`.
 *
 * @experimental
 */
export class ApplicationModule {
}
}
declare module '@angular/core/src/application_module' {
export * from '~@angular/core/src/application_module';
}

// Generated by typings
// Source: node_modules/@angular/core/src/profile/wtf_impl.d.ts
declare module '~@angular/core/src/profile/wtf_impl' {
/**
 * A scope function for the Web Tracing Framework (WTF).
 *
 * @experimental
 */
export interface WtfScopeFn {
    (arg0?: any, arg1?: any): any;
}
export interface Range {
}
export interface Scope {
    (...args: any[]): any;
}
export function detectWTF(): boolean;
export function createScope(signature: string, flags?: any): any;
export function leave<T>(scope: Scope, returnValue?: T): T;
export function startTimeRange(rangeType: string, action: string): Range;
export function endTimeRange(range: Range): void;
}
declare module '@angular/core/src/profile/wtf_impl' {
export * from '~@angular/core/src/profile/wtf_impl';
}

// Generated by typings
// Source: node_modules/@angular/core/src/profile/profile.d.ts
declare module '~@angular/core/src/profile/profile' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { WtfScopeFn } from '~@angular/core/src/profile/wtf_impl';
export { WtfScopeFn } from '~@angular/core/src/profile/wtf_impl';
/**
 * True if WTF is enabled.
 */
export const wtfEnabled: boolean;
/**
 * Create trace scope.
 *
 * Scopes must be strictly nested and are analogous to stack frames, but
 * do not have to follow the stack frames. Instead it is recommended that they follow logical
 * nesting. You may want to use
 * [Event
 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
 * as they are defined in WTF.
 *
 * Used to mark scope entry. The return value is used to leave the scope.
 *
 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
 *
 *     someMethod() {
 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
 *        // DO SOME WORK HERE
 *        return wtfLeave(s, 123); // Return value 123
 *     }
 *
 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
 * negatively impact the performance of your application. For this reason we recommend that
 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
 * exception, will produce incorrect trace, but presence of exception signifies logic error which
 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
 * an exception is expected during normal execution while profiling.
 *
 * @experimental
 */
export var wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn;
/**
 * Used to mark end of Scope.
 *
 * - `scope` to end.
 * - `returnValue` (optional) to be passed to the WTF.
 *
 * Returns the `returnValue for easy chaining.
 * @experimental
 */
export var wtfLeave: <T>(scope: any, returnValue?: T) => T;
/**
 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
 * enabled.
 *
 *     someMethod() {
 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
 *        var future = new Future.delay(5).then((_) {
 *          wtfEndTimeRange(s);
 *        });
 *     }
 * @experimental
 */
export var wtfStartTimeRange: (rangeType: string, action: string) => any;
/**
 * Ends a async time range operation.
 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
 * enabled.
 * @experimental
 */
export var wtfEndTimeRange: (range: any) => void;
}
declare module '@angular/core/src/profile/profile' {
export * from '~@angular/core/src/profile/profile';
}

// Generated by typings
// Source: node_modules/@angular/core/src/type.d.ts
declare module '~@angular/core/src/type' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @whatItDoes Represents a type that a Component or other object is instances of.
 *
 * @description
 *
 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
 * the `MyCustomComponent` constructor function.
 *
 * @stable
 */
export const Type: FunctionConstructor;
export interface Type<T> extends Function {
    new (...args: any[]): T;
}
}
declare module '@angular/core/src/type' {
export * from '~@angular/core/src/type';
}

// Generated by typings
// Source: node_modules/@angular/core/src/facade/async.d.ts
declare module '~@angular/core/src/facade/async' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Subject } from 'rxjs/Subject';
export { Observable } from 'rxjs/Observable';
export { Subject } from 'rxjs/Subject';
/**
 * Use by directives and components to emit custom Events.
 *
 * ### Examples
 *
 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
 * title gets clicked:
 *
 * ```
 * @Component({
 *   selector: 'zippy',
 *   template: `
 *   <div class="zippy">
 *     <div (click)="toggle()">Toggle</div>
 *     <div [hidden]="!visible">
 *       <ng-content></ng-content>
 *     </div>
 *  </div>`})
 * export class Zippy {
 *   visible: boolean = true;
 *   @Output() open: EventEmitter<any> = new EventEmitter();
 *   @Output() close: EventEmitter<any> = new EventEmitter();
 *
 *   toggle() {
 *     this.visible = !this.visible;
 *     if (this.visible) {
 *       this.open.emit(null);
 *     } else {
 *       this.close.emit(null);
 *     }
 *   }
 * }
 * ```
 *
 * The events payload can be accessed by the parameter `$event` on the components output event
 * handler:
 *
 * ```
 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
 * ```
 *
 * Uses Rx.Observable but provides an adapter to make it work as specified here:
 * https://github.com/jhusain/observable-spec
 *
 * Once a reference implementation of the spec is available, switch to it.
 * @stable
 */
export class EventEmitter<T> extends Subject<T> {
    __isAsync: boolean;
    /**
     * Creates an instance of [EventEmitter], which depending on [isAsync],
     * delivers events synchronously or asynchronously.
     */
    constructor(isAsync?: boolean);
    emit(value?: T): void;
    subscribe(generatorOrNext?: any, error?: any, complete?: any): any;
}
}
declare module '@angular/core/src/facade/async' {
export * from '~@angular/core/src/facade/async';
}

// Generated by typings
// Source: node_modules/@angular/core/src/error_handler.d.ts
declare module '~@angular/core/src/error_handler' {
/**
 * @whatItDoes Provides a hook for centralized exception handling.
 *
 * @description
 *
 * The default implementation of `ErrorHandler` prints error messages to the `console`. To
 * intercept error handling, write a custom exception handler that replaces this default as
 * appropriate for your app.
 *
 * ### Example
 *
 * ```
 * class MyErrorHandler implements ErrorHandler {
 *   handleError(error) {
 *     // do something with the exception
 *   }
 * }
 *
 * @NgModule({
 *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
 * })
 * class MyModule {}
 * ```
 *
 * @stable
 */
export class ErrorHandler {
    constructor(rethrowError?: boolean);
    handleError(error: any): void;
}
}
declare module '@angular/core/src/error_handler' {
export * from '~@angular/core/src/error_handler';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_constants.d.ts
declare module '~@angular/core/src/animation/animation_constants' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export const FILL_STYLE_FLAG: string;
export const ANY_STATE: string;
export const DEFAULT_STATE: string;
export const EMPTY_STATE: string;
}
declare module '@angular/core/src/animation/animation_constants' {
export * from '~@angular/core/src/animation/animation_constants';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_group_player.d.ts
declare module '~@angular/core/src/animation/animation_group_player' {
import { AnimationPlayer } from '~@angular/core/src/animation/animation_player';
export class AnimationGroupPlayer implements AnimationPlayer {
    private _players;
    private _onDoneFns;
    private _onStartFns;
    private _finished;
    private _started;
    parentPlayer: AnimationPlayer;
    constructor(_players: AnimationPlayer[]);
    private _onFinish();
    init(): void;
    onStart(fn: () => void): void;
    onDone(fn: () => void): void;
    hasStarted(): boolean;
    play(): void;
    pause(): void;
    restart(): void;
    finish(): void;
    destroy(): void;
    reset(): void;
    setPosition(p: any): void;
    getPosition(): number;
}
}
declare module '@angular/core/src/animation/animation_group_player' {
export * from '~@angular/core/src/animation/animation_group_player';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_keyframe.d.ts
declare module '~@angular/core/src/animation/animation_keyframe' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationStyles } from '~@angular/core/src/animation/animation_styles';
export class AnimationKeyframe {
    offset: number;
    styles: AnimationStyles;
    constructor(offset: number, styles: AnimationStyles);
}
}
declare module '@angular/core/src/animation/animation_keyframe' {
export * from '~@angular/core/src/animation/animation_keyframe';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_sequence_player.d.ts
declare module '~@angular/core/src/animation/animation_sequence_player' {
import { AnimationPlayer } from '~@angular/core/src/animation/animation_player';
export class AnimationSequencePlayer implements AnimationPlayer {
    private _players;
    private _currentIndex;
    private _activePlayer;
    private _onDoneFns;
    private _onStartFns;
    private _finished;
    private _started;
    parentPlayer: AnimationPlayer;
    constructor(_players: AnimationPlayer[]);
    private _onNext(start);
    private _onFinish();
    init(): void;
    onStart(fn: () => void): void;
    onDone(fn: () => void): void;
    hasStarted(): boolean;
    play(): void;
    pause(): void;
    restart(): void;
    reset(): void;
    finish(): void;
    destroy(): void;
    setPosition(p: any): void;
    getPosition(): number;
}
}
declare module '@angular/core/src/animation/animation_sequence_player' {
export * from '~@angular/core/src/animation/animation_sequence_player';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_style_util.d.ts
declare module '~@angular/core/src/animation/animation_style_util' {
export function prepareFinalAnimationStyles(previousStyles: {
    [key: string]: string | number;
}, newStyles: {
    [key: string]: string | number;
}, nullValue?: string): {
    [key: string]: string;
};
export function balanceAnimationKeyframes(collectedStyles: {
    [key: string]: string | number;
}, finalStateStyles: {
    [key: string]: string | number;
}, keyframes: any[]): any[];
export function clearStyles(styles: {
    [key: string]: string | number;
}): {
    [key: string]: string;
};
export function collectAndResolveStyles(collection: {
    [key: string]: string | number;
}, styles: {
    [key: string]: string | number;
}[]): {
    [key: string]: string | number;
}[];
export function renderStyles(element: any, renderer: any, styles: {
    [key: string]: string | number;
}): void;
export function flattenStyles(styles: {
    [key: string]: string | number;
}[]): {
    [key: string]: string;
};
}
declare module '@angular/core/src/animation/animation_style_util' {
export * from '~@angular/core/src/animation/animation_style_util';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_styles.d.ts
declare module '~@angular/core/src/animation/animation_styles' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export class AnimationStyles {
    styles: {
        [key: string]: string | number;
    }[];
    constructor(styles: {
        [key: string]: string | number;
    }[]);
}
}
declare module '@angular/core/src/animation/animation_styles' {
export * from '~@angular/core/src/animation/animation_styles';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_transition.d.ts
declare module '~@angular/core/src/animation/animation_transition' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationPlayer } from '~@angular/core/src/animation/animation_player';
import { AnimationTransitionEvent } from '~@angular/core/src/animation/animation_transition_event';
export class AnimationTransition {
    private _player;
    private _fromState;
    private _toState;
    private _totalTime;
    constructor(_player: AnimationPlayer, _fromState: string, _toState: string, _totalTime: number);
    private _createEvent(phaseName);
    onStart(callback: (event: AnimationTransitionEvent) => any): void;
    onDone(callback: (event: AnimationTransitionEvent) => any): void;
}
}
declare module '@angular/core/src/animation/animation_transition' {
export * from '~@angular/core/src/animation/animation_transition';
}

// Generated by typings
// Source: node_modules/@angular/core/src/facade/lang.d.ts
declare module '~@angular/core/src/facade/lang' {

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export interface BrowserNodeGlobal {
    Object: typeof Object;
    Array: typeof Array;
    Map: typeof Map;
    Set: typeof Set;
    Date: DateConstructor;
    RegExp: RegExpConstructor;
    JSON: typeof JSON;
    Math: any;
    assert(condition: any): void;
    Reflect: any;
    getAngularTestability: Function;
    getAllAngularTestabilities: Function;
    getAllAngularRootElements: Function;
    frameworkStabilizers: Array<Function>;
    setTimeout: Function;
    clearTimeout: Function;
    setInterval: Function;
    clearInterval: Function;
    encodeURI: Function;
}
export function scheduleMicroTask(fn: Function): void;
const _global: BrowserNodeGlobal;
export { _global as global };
export function getTypeNameForDebugging(type: any): string;
export function isPresent(obj: any): boolean;
export function isBlank(obj: any): boolean;
export function isStrictStringMap(obj: any): boolean;
export function isDate(obj: any): obj is Date;
export function stringify(token: any): string;
export class NumberWrapper {
    static parseIntAutoRadix(text: string): number;
    static parseInt(text: string, radix: number): number;
    static isNumeric(value: any): boolean;
}
export function looseIdentical(a: any, b: any): boolean;
export function isJsObject(o: any): boolean;
export function print(obj: Error | Object): void;
export function warn(obj: Error | Object): void;
export function setValueOnPath(global: any, path: string, value: any): void;
export function getSymbolIterator(): string | symbol;
export function isPrimitive(obj: any): boolean;
export function escapeRegExp(s: string): string;
}
declare module '@angular/core/src/facade/lang' {
export * from '~@angular/core/src/facade/lang';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/change_detection_util.d.ts
declare module '~@angular/core/src/change_detection/change_detection_util' {
export { looseIdentical } from '~@angular/core/src/facade/lang';
export const UNINITIALIZED: {
    toString: () => string;
};
export function devModeEqual(a: any, b: any): boolean;
/**
 * Indicates that the result of a {@link Pipe} transformation has changed even though the
 * reference
 * has not changed.
 *
 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
 *
 * Example:
 *
 * ```
 * if (this._latestValue === this._latestReturnedValue) {
 *    return this._latestReturnedValue;
 *  } else {
 *    this._latestReturnedValue = this._latestValue;
 *    return WrappedValue.wrap(this._latestValue); // this will force update
 *  }
 * ```
 * @stable
 */
export class WrappedValue {
    wrapped: any;
    constructor(wrapped: any);
    static wrap(value: any): WrappedValue;
}
/**
 * Helper class for unwrapping WrappedValue s
 */
export class ValueUnwrapper {
    hasWrappedValue: boolean;
    unwrap(value: any): any;
    reset(): void;
}
/**
 * Represents a basic change from a previous to a new value.
 * @stable
 */
export class SimpleChange {
    previousValue: any;
    currentValue: any;
    constructor(previousValue: any, currentValue: any);
    /**
     * Check whether the new value is the first value assigned.
     */
    isFirstChange(): boolean;
}
}
declare module '@angular/core/src/change_detection/change_detection_util' {
export * from '~@angular/core/src/change_detection/change_detection_util';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/constants.d.ts
declare module '~@angular/core/src/change_detection/constants' {
/**
 * Describes within the change detector which strategy will be used the next time change
 * detection is triggered.
 * @stable
 */
export enum ChangeDetectionStrategy {
    /**
     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
     */
    OnPush = 0,
    /**
     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
     */
    Default = 1,
}
/**
 * Describes the status of the detector.
 */
export enum ChangeDetectorStatus {
    /**
     * `CheckedOnce` means that after calling detectChanges the mode of the change detector
     * will become `Checked`.
     */
    CheckOnce = 0,
    /**
     * `Checked` means that the change detector should be skipped until its mode changes to
     * `CheckOnce`.
     */
    Checked = 1,
    /**
     * `CheckAlways` means that after calling detectChanges the mode of the change detector
     * will remain `CheckAlways`.
     */
    CheckAlways = 2,
    /**
     * `Detached` means that the change detector sub tree is not a part of the main tree and
     * should be skipped.
     */
    Detached = 3,
    /**
     * `Errored` means that the change detector encountered an error checking a binding
     * or calling a directive lifecycle method and is now in an inconsistent state. Change
     * detectors in this state will no longer detect changes.
     */
    Errored = 4,
    /**
     * `Destroyed` means that the change detector is destroyed.
     */
    Destroyed = 5,
}
export function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy): boolean;
}
declare module '@angular/core/src/change_detection/constants' {
export * from '~@angular/core/src/change_detection/constants';
}

// Generated by typings
// Source: node_modules/@angular/core/src/debug/debug_renderer.d.ts
declare module '~@angular/core/src/debug/debug_renderer' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationKeyframe } from '~@angular/core/src/animation/animation_keyframe';
import { AnimationPlayer } from '~@angular/core/src/animation/animation_player';
import { AnimationStyles } from '~@angular/core/src/animation/animation_styles';
import { RenderComponentType, RenderDebugInfo, Renderer, RootRenderer } from '~@angular/core/src/render/api';
export class DebugDomRootRenderer implements RootRenderer {
    private _delegate;
    constructor(_delegate: RootRenderer);
    renderComponent(componentProto: RenderComponentType): Renderer;
}
export class DebugDomRenderer implements Renderer {
    private _delegate;
    constructor(_delegate: Renderer);
    selectRootElement(selectorOrNode: string | any, debugInfo?: RenderDebugInfo): any;
    createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;
    createViewRoot(hostElement: any): any;
    createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;
    createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;
    projectNodes(parentElement: any, nodes: any[]): void;
    attachViewAfter(node: any, viewRootNodes: any[]): void;
    detachView(viewRootNodes: any[]): void;
    destroyView(hostElement: any, viewAllNodes: any[]): void;
    listen(renderElement: any, name: string, callback: Function): Function;
    listenGlobal(target: string, name: string, callback: Function): Function;
    setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;
    setElementAttribute(renderElement: any, attributeName: string, attributeValue: string): void;
    setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string): void;
    setElementClass(renderElement: any, className: string, isAdd: boolean): void;
    setElementStyle(renderElement: any, styleName: string, styleValue: string): void;
    invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;
    setText(renderNode: any, text: string): void;
    animate(element: any, startingStyles: AnimationStyles, keyframes: AnimationKeyframe[], duration: number, delay: number, easing: string): AnimationPlayer;
}
}
declare module '@angular/core/src/debug/debug_renderer' {
export * from '~@angular/core/src/debug/debug_renderer';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/debug_context.d.ts
declare module '~@angular/core/src/linker/debug_context' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di';
import { RenderDebugInfo } from '~@angular/core/src/render/api';
import { DebugAppView } from '~@angular/core/src/linker/view';
export class StaticNodeDebugInfo {
    providerTokens: any[];
    componentToken: any;
    refTokens: {
        [key: string]: any;
    };
    constructor(providerTokens: any[], componentToken: any, refTokens: {
        [key: string]: any;
    });
}
export class DebugContext implements RenderDebugInfo {
    private _view;
    private _nodeIndex;
    private _tplRow;
    private _tplCol;
    constructor(_view: DebugAppView<any>, _nodeIndex: number, _tplRow: number, _tplCol: number);
    private _staticNodeInfo;
    context: any;
    component: any;
    componentRenderElement: any;
    injector: Injector;
    renderNode: any;
    providerTokens: any[];
    source: string;
    references: {
        [key: string]: any;
    };
}
}
declare module '@angular/core/src/linker/debug_context' {
export * from '~@angular/core/src/linker/debug_context';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/element.d.ts
declare module '~@angular/core/src/linker/element' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di/injector';
import { ElementRef } from '~@angular/core/src/linker/element_ref';
import { QueryList } from '~@angular/core/src/linker/query_list';
import { AppView } from '~@angular/core/src/linker/view';
import { ViewContainerRef_ } from '~@angular/core/src/linker/view_container_ref';
/**
 * An AppElement is created for elements that have a ViewContainerRef,
 * a nested component or a <template> element to keep data around
 * that is needed for later instantiations.
 */
export class AppElement {
    index: number;
    parentIndex: number;
    parentView: AppView<any>;
    nativeElement: any;
    nestedViews: AppView<any>[];
    componentView: AppView<any>;
    component: any;
    componentConstructorViewQueries: QueryList<any>[];
    constructor(index: number, parentIndex: number, parentView: AppView<any>, nativeElement: any);
    elementRef: ElementRef;
    vcRef: ViewContainerRef_;
    initComponent(component: any, componentConstructorViewQueries: QueryList<any>[], view: AppView<any>): void;
    parentInjector: Injector;
    injector: Injector;
    mapNestedViews(nestedViewClass: any, callback: Function): any[];
    moveView(view: AppView<any>, currentIndex: number): void;
    attachView(view: AppView<any>, viewIndex: number): void;
    detachView(viewIndex: number): AppView<any>;
}
}
declare module '@angular/core/src/linker/element' {
export * from '~@angular/core/src/linker/element';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/animation_view_context.d.ts
declare module '~@angular/core/src/linker/animation_view_context' {
import { AnimationPlayer } from '~@angular/core/src/animation/animation_player';
export class AnimationViewContext {
    private _players;
    onAllActiveAnimationsDone(callback: () => any): void;
    queueAnimation(element: any, animationName: string, player: AnimationPlayer): void;
    cancelActiveAnimation(element: any, animationName: string, removeAllAnimations?: boolean): void;
}
}
declare module '@angular/core/src/linker/animation_view_context' {
export * from '~@angular/core/src/linker/animation_view_context';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/view.d.ts
declare module '~@angular/core/src/linker/view' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectorRef, ChangeDetectorStatus } from '~@angular/core/src/change_detection/change_detection';
import { Injector } from '~@angular/core/src/di/injector';
import { RenderComponentType, Renderer } from '~@angular/core/src/render/api';
import { AnimationViewContext } from '~@angular/core/src/linker/animation_view_context';
import { DebugContext, StaticNodeDebugInfo } from '~@angular/core/src/linker/debug_context';
import { AppElement } from '~@angular/core/src/linker/element';
import { ViewRef_ } from '~@angular/core/src/linker/view_ref';
import { ViewType } from '~@angular/core/src/linker/view_type';
import { ViewUtils } from '~@angular/core/src/linker/view_utils';
/**
 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
 *
 */
export abstract class AppView<T> {
    clazz: any;
    componentType: RenderComponentType;
    type: ViewType;
    viewUtils: ViewUtils;
    parentInjector: Injector;
    declarationAppElement: AppElement;
    cdMode: ChangeDetectorStatus;
    ref: ViewRef_<T>;
    rootNodesOrAppElements: any[];
    allNodes: any[];
    disposables: Function[];
    subscriptions: any[];
    contentChildren: AppView<any>[];
    viewChildren: AppView<any>[];
    viewContainerElement: AppElement;
    numberOfChecks: number;
    projectableNodes: Array<any | any[]>;
    renderer: Renderer;
    private _hasExternalHostElement;
    private _animationContext;
    context: T;
    constructor(clazz: any, componentType: RenderComponentType, type: ViewType, viewUtils: ViewUtils, parentInjector: Injector, declarationAppElement: AppElement, cdMode: ChangeDetectorStatus);
    animationContext: AnimationViewContext;
    destroyed: boolean;
    create(context: T, givenProjectableNodes: Array<any | any[]>, rootSelectorOrNode: string | any): AppElement;
    /**
     * Overwritten by implementations.
     * Returns the AppElement for the host element for ViewType.HOST.
     */
    createInternal(rootSelectorOrNode: string | any): AppElement;
    init(rootNodesOrAppElements: any[], allNodes: any[], disposables: Function[], subscriptions: any[]): void;
    injectorGet(token: any, nodeIndex: number, notFoundResult: any): any;
    /**
     * Overwritten by implementations
     */
    injectorGetInternal(token: any, nodeIndex: number, notFoundResult: any): any;
    injector(nodeIndex: number): Injector;
    destroy(): void;
    private _destroyRecurse();
    destroyLocal(): void;
    /**
     * Overwritten by implementations
     */
    destroyInternal(): void;
    /**
     * Overwritten by implementations
     */
    detachInternal(): void;
    detach(): void;
    changeDetectorRef: ChangeDetectorRef;
    parent: AppView<any>;
    flatRootNodes: any[];
    lastRootNode: any;
    /**
     * Overwritten by implementations
     */
    dirtyParentQueriesInternal(): void;
    detectChanges(throwOnChange: boolean): void;
    /**
     * Overwritten by implementations
     */
    detectChangesInternal(throwOnChange: boolean): void;
    detectContentChildrenChanges(throwOnChange: boolean): void;
    detectViewChildrenChanges(throwOnChange: boolean): void;
    markContentChildAsMoved(renderAppElement: AppElement): void;
    addToContentChildren(renderAppElement: AppElement): void;
    removeFromContentChildren(renderAppElement: AppElement): void;
    markAsCheckOnce(): void;
    markPathToRootAsCheckOnce(): void;
    eventHandler<E, R>(cb: (event?: E) => R): (event?: E) => R;
    throwDestroyedError(details: string): void;
}
export class DebugAppView<T> extends AppView<T> {
    staticNodeDebugInfos: StaticNodeDebugInfo[];
    private _currentDebugContext;
    constructor(clazz: any, componentType: RenderComponentType, type: ViewType, viewUtils: ViewUtils, parentInjector: Injector, declarationAppElement: AppElement, cdMode: ChangeDetectorStatus, staticNodeDebugInfos: StaticNodeDebugInfo[]);
    create(context: T, givenProjectableNodes: Array<any | any[]>, rootSelectorOrNode: string | any): AppElement;
    injectorGet(token: any, nodeIndex: number, notFoundResult: any): any;
    detach(): void;
    destroyLocal(): void;
    detectChanges(throwOnChange: boolean): void;
    private _resetDebug();
    debug(nodeIndex: number, rowNum: number, colNum: number): DebugContext;
    private _rethrowWithContext(e);
    eventHandler<E, R>(cb: (event?: E) => R): (event?: E) => R;
}
}
declare module '@angular/core/src/linker/view' {
export * from '~@angular/core/src/linker/view';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/view_type.d.ts
declare module '~@angular/core/src/linker/view_type' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export enum ViewType {
    HOST = 0,
    COMPONENT = 1,
    EMBEDDED = 2,
}
}
declare module '@angular/core/src/linker/view_type' {
export * from '~@angular/core/src/linker/view_type';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/view_utils.d.ts
declare module '~@angular/core/src/linker/view_utils' {
import { SimpleChange } from '~@angular/core/src/change_detection/change_detection';
import { ViewEncapsulation } from '~@angular/core/src/metadata/view';
import { RenderComponentType, RenderDebugInfo, Renderer, RootRenderer } from '~@angular/core/src/render/api';
import { Sanitizer } from '~@angular/core/src/security';
export class ViewUtils {
    private _renderer;
    private _appId;
    sanitizer: Sanitizer;
    private _nextCompTypeId;
    constructor(_renderer: RootRenderer, _appId: string, sanitizer: Sanitizer);
    /**
     * Used by the generated code
     */
    createRenderComponentType(templateUrl: string, slotCount: number, encapsulation: ViewEncapsulation, styles: Array<string | any[]>, animations: {
        [key: string]: Function;
    }): RenderComponentType;
}
export function flattenNestedViewRenderNodes(nodes: any[]): any[];
export function ensureSlotCount(projectableNodes: any[][], expectedSlotCount: number): any[][];
export const MAX_INTERPOLATION_VALUES: number;
export function interpolate(valueCount: number, c0: string, a1: any, c1: string, a2?: any, c2?: string, a3?: any, c3?: string, a4?: any, c4?: string, a5?: any, c5?: string, a6?: any, c6?: string, a7?: any, c7?: string, a8?: any, c8?: string, a9?: any, c9?: string): string;
export function checkBinding(throwOnChange: boolean, oldValue: any, newValue: any): boolean;
export function castByValue<T>(input: any, value: T): T;
export const EMPTY_ARRAY: any[];
export const EMPTY_MAP: {};
export function pureProxy1<P0, R>(fn: (p0: P0) => R): (p0: P0) => R;
export function pureProxy2<P0, P1, R>(fn: (p0: P0, p1: P1) => R): (p0: P0, p1: P1) => R;
export function pureProxy3<P0, P1, P2, R>(fn: (p0: P0, p1: P1, p2: P2) => R): (p0: P0, p1: P1, p2: P2) => R;
export function pureProxy4<P0, P1, P2, P3, R>(fn: (p0: P0, p1: P1, p2: P2, p3: P3) => R): (p0: P0, p1: P1, p2: P2, p3: P3) => R;
export function pureProxy5<P0, P1, P2, P3, P4, R>(fn: (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4) => R): (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4) => R;
export function pureProxy6<P0, P1, P2, P3, P4, P5, R>(fn: (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5) => R): (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5) => R;
export function pureProxy7<P0, P1, P2, P3, P4, P5, P6, R>(fn: (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6) => R): (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6) => R;
export function pureProxy8<P0, P1, P2, P3, P4, P5, P6, P7, R>(fn: (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7) => R): (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7) => R;
export function pureProxy9<P0, P1, P2, P3, P4, P5, P6, P7, P8, R>(fn: (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8) => R): (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8) => R;
export function pureProxy10<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, R>(fn: (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9) => R): (p0: P0, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9) => R;
export function setBindingDebugInfoForChanges(renderer: Renderer, el: any, changes: {
    [key: string]: SimpleChange;
}): void;
export function setBindingDebugInfo(renderer: Renderer, el: any, propName: string, value: any): void;
export function createRenderElement(renderer: Renderer, parentElement: any, name: string, attrs: InlineArray<string>, debugInfo?: RenderDebugInfo): any;
export function selectOrCreateRenderHostElement(renderer: Renderer, elementName: string, attrs: InlineArray<string>, rootSelectorOrNode: string | any, debugInfo?: RenderDebugInfo): any;
export interface InlineArray<T> {
    length: number;
    get(index: number): T;
}
export class InlineArray2<T> implements InlineArray<T> {
    length: number;
    private _v0;
    private _v1;
    constructor(length: number, _v0?: T, _v1?: T);
    get(index: number): T;
}
export class InlineArray4<T> implements InlineArray<T> {
    length: number;
    private _v0;
    private _v1;
    private _v2;
    private _v3;
    constructor(length: number, _v0?: T, _v1?: T, _v2?: T, _v3?: T);
    get(index: number): T;
}
export class InlineArray8<T> implements InlineArray<T> {
    length: number;
    private _v0;
    private _v1;
    private _v2;
    private _v3;
    private _v4;
    private _v5;
    private _v6;
    private _v7;
    constructor(length: number, _v0?: T, _v1?: T, _v2?: T, _v3?: T, _v4?: T, _v5?: T, _v6?: T, _v7?: T);
    get(index: number): T;
}
export class InlineArray16<T> implements InlineArray<T> {
    length: number;
    private _v0;
    private _v1;
    private _v2;
    private _v3;
    private _v4;
    private _v5;
    private _v6;
    private _v7;
    private _v8;
    private _v9;
    private _v10;
    private _v11;
    private _v12;
    private _v13;
    private _v14;
    private _v15;
    constructor(length: number, _v0?: T, _v1?: T, _v2?: T, _v3?: T, _v4?: T, _v5?: T, _v6?: T, _v7?: T, _v8?: T, _v9?: T, _v10?: T, _v11?: T, _v12?: T, _v13?: T, _v14?: T, _v15?: T);
    get(index: number): T;
}
export class InlineArrayDynamic<T> implements InlineArray<T> {
    length: number;
    private _values;
    constructor(length: number, ...values: any[]);
    get(index: number): any;
}
export const EMPTY_INLINE_ARRAY: InlineArray<any>;
}
declare module '@angular/core/src/linker/view_utils' {
export * from '~@angular/core/src/linker/view_utils';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/reflector.d.ts
declare module '~@angular/core/src/reflection/reflector' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
import { PlatformReflectionCapabilities } from '~@angular/core/src/reflection/platform_reflection_capabilities';
import { ReflectorReader } from '~@angular/core/src/reflection/reflector_reader';
import { GetterFn, MethodFn, SetterFn } from '~@angular/core/src/reflection/types';
export { PlatformReflectionCapabilities } from '~@angular/core/src/reflection/platform_reflection_capabilities';
export { GetterFn, MethodFn, SetterFn } from '~@angular/core/src/reflection/types';
/**
 * Provides access to reflection data about symbols. Used internally by Angular
 * to power dependency injection and compilation.
 */
export class Reflector extends ReflectorReader {
    reflectionCapabilities: PlatformReflectionCapabilities;
    constructor(reflectionCapabilities: PlatformReflectionCapabilities);
    updateCapabilities(caps: PlatformReflectionCapabilities): void;
    factory(type: Type<any>): Function;
    parameters(typeOrFunc: Type<any>): any[][];
    annotations(typeOrFunc: Type<any>): any[];
    propMetadata(typeOrFunc: Type<any>): {
        [key: string]: any[];
    };
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    getter(name: string): GetterFn;
    setter(name: string): SetterFn;
    method(name: string): MethodFn;
    importUri(type: any): string;
    resolveIdentifier(name: string, moduleUrl: string, runtime: any): any;
    resolveEnum(identifier: any, name: string): any;
}
}
declare module '@angular/core/src/reflection/reflector' {
export * from '~@angular/core/src/reflection/reflector';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/reflection.d.ts
declare module '~@angular/core/src/reflection/reflection' {
import { Reflector } from '~@angular/core/src/reflection/reflector';
export { Reflector } from '~@angular/core/src/reflection/reflector';
/**
 * The {@link Reflector} used internally in Angular to access metadata
 * about symbols.
 */
export const reflector: Reflector;
}
declare module '@angular/core/src/reflection/reflection' {
export * from '~@angular/core/src/reflection/reflection';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/platform_reflection_capabilities.d.ts
declare module '~@angular/core/src/reflection/platform_reflection_capabilities' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
import { GetterFn, MethodFn, SetterFn } from '~@angular/core/src/reflection/types';
export interface PlatformReflectionCapabilities {
    isReflectionEnabled(): boolean;
    factory(type: Type<any>): Function;
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    parameters(type: Type<any>): any[][];
    annotations(type: Type<any>): any[];
    propMetadata(typeOrFunc: Type<any>): {
        [key: string]: any[];
    };
    getter(name: string): GetterFn;
    setter(name: string): SetterFn;
    method(name: string): MethodFn;
    importUri(type: Type<any>): string;
    resolveIdentifier(name: string, moduleUrl: string, runtime: any): any;
    resolveEnum(enumIdentifier: any, name: string): any;
}
}
declare module '@angular/core/src/reflection/platform_reflection_capabilities' {
export * from '~@angular/core/src/reflection/platform_reflection_capabilities';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/reflection_capabilities.d.ts
declare module '~@angular/core/src/reflection/reflection_capabilities' {
import { Type } from '~@angular/core/src/type';
import { PlatformReflectionCapabilities } from '~@angular/core/src/reflection/platform_reflection_capabilities';
import { GetterFn, MethodFn, SetterFn } from '~@angular/core/src/reflection/types';
export class ReflectionCapabilities implements PlatformReflectionCapabilities {
    private _reflect;
    constructor(reflect?: any);
    isReflectionEnabled(): boolean;
    factory<T>(t: Type<T>): (args: any[]) => T;
    parameters(type: Type<any>): any[][];
    annotations(typeOrFunc: Type<any>): any[];
    propMetadata(typeOrFunc: any): {
        [key: string]: any[];
    };
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    getter(name: string): GetterFn;
    setter(name: string): SetterFn;
    method(name: string): MethodFn;
    importUri(type: any): string;
    resolveIdentifier(name: string, moduleUrl: string, runtime: any): any;
    resolveEnum(enumIdentifier: any, name: string): any;
}
}
declare module '@angular/core/src/reflection/reflection_capabilities' {
export * from '~@angular/core/src/reflection/reflection_capabilities';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/reflector_reader.d.ts
declare module '~@angular/core/src/reflection/reflector_reader' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Provides read-only access to reflection data about symbols. Used internally by Angular
 * to power dependency injection and compilation.
 */
export abstract class ReflectorReader {
    abstract parameters(typeOrFunc: any): any[][];
    abstract annotations(typeOrFunc: any): any[];
    abstract propMetadata(typeOrFunc: any): {
        [key: string]: any[];
    };
    abstract importUri(typeOrFunc: any): string;
    abstract resolveIdentifier(name: string, moduleUrl: string, runtime: any): any;
    abstract resolveEnum(identifier: any, name: string): any;
}
}
declare module '@angular/core/src/reflection/reflector_reader' {
export * from '~@angular/core/src/reflection/reflector_reader';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/types.d.ts
declare module '~@angular/core/src/reflection/types' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export type SetterFn = (obj: any, value: any) => void;
export type GetterFn = (obj: any) => any;
export type MethodFn = (obj: any, args: any[]) => any;
}
declare module '@angular/core/src/reflection/types' {
export * from '~@angular/core/src/reflection/types';
}

// Generated by typings
// Source: node_modules/@angular/core/src/util/lang.d.ts
declare module '~@angular/core/src/util/lang' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export function isPromise(obj: any): obj is Promise<any>;
}
declare module '@angular/core/src/util/lang' {
export * from '~@angular/core/src/util/lang';
}

// Generated by typings
// Source: node_modules/@angular/core/src/core_private_export.d.ts
declare module '~@angular/core/src/core_private_export' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ANY_STATE as ANY_STATE_, DEFAULT_STATE as DEFAULT_STATE_, EMPTY_STATE as EMPTY_STATE_, FILL_STYLE_FLAG as FILL_STYLE_FLAG_ } from '~@angular/core/src/animation/animation_constants';
import { AnimationGroupPlayer as AnimationGroupPlayer_ } from '~@angular/core/src/animation/animation_group_player';
import { AnimationKeyframe as AnimationKeyframe_ } from '~@angular/core/src/animation/animation_keyframe';
import { AnimationPlayer as AnimationPlayer_, NoOpAnimationPlayer as NoOpAnimationPlayer_ } from '~@angular/core/src/animation/animation_player';
import { AnimationSequencePlayer as AnimationSequencePlayer_ } from '~@angular/core/src/animation/animation_sequence_player';
import * as animationUtils from '~@angular/core/src/animation/animation_style_util';
import { AnimationStyles as AnimationStyles_ } from '~@angular/core/src/animation/animation_styles';
import { AnimationTransition } from '~@angular/core/src/animation/animation_transition';
import * as change_detection_util from '~@angular/core/src/change_detection/change_detection_util';
import * as constants from '~@angular/core/src/change_detection/constants';
import * as console from '~@angular/core/src/console';
import * as debug from '~@angular/core/src/debug/debug_renderer';
import * as reflective_provider from '~@angular/core/src/di/reflective_provider';
import { ComponentStillLoadingError } from '~@angular/core/src/linker/compiler';
import * as component_factory_resolver from '~@angular/core/src/linker/component_factory_resolver';
import * as debug_context from '~@angular/core/src/linker/debug_context';
import * as element from '~@angular/core/src/linker/element';
import * as ng_module_factory from '~@angular/core/src/linker/ng_module_factory';
import * as ng_module_factory_loader from '~@angular/core/src/linker/ng_module_factory_loader';
import * as template_ref from '~@angular/core/src/linker/template_ref';
import * as view from '~@angular/core/src/linker/view';
import * as view_type from '~@angular/core/src/linker/view_type';
import * as view_utils from '~@angular/core/src/linker/view_utils';
import * as lifecycle_hooks from '~@angular/core/src/metadata/lifecycle_hooks';
import * as metadata_view from '~@angular/core/src/metadata/view';
import * as reflection from '~@angular/core/src/reflection/reflection';
import * as reflection_capabilities from '~@angular/core/src/reflection/reflection_capabilities';
import * as reflector_reader from '~@angular/core/src/reflection/reflector_reader';
import * as reflection_types from '~@angular/core/src/reflection/types';
import * as api from '~@angular/core/src/render/api';
import * as decorators from '~@angular/core/src/util/decorators';
import { isPromise } from '~@angular/core/src/util/lang';
export var __core_private__: {
    isDefaultChangeDetectionStrategy: typeof constants.isDefaultChangeDetectionStrategy;
    ChangeDetectorStatus: typeof constants.ChangeDetectorStatus;
    _ChangeDetectorStatus?: constants.ChangeDetectorStatus;
    constructDependencies: typeof reflective_provider.constructDependencies;
    LifecycleHooks: typeof lifecycle_hooks.LifecycleHooks;
    _LifecycleHooks?: lifecycle_hooks.LifecycleHooks;
    LIFECYCLE_HOOKS_VALUES: typeof lifecycle_hooks.LIFECYCLE_HOOKS_VALUES;
    ReflectorReader: typeof reflector_reader.ReflectorReader;
    _ReflectorReader?: reflector_reader.ReflectorReader;
    _SetterFn?: reflection_types.SetterFn;
    _GetterFn?: reflection_types.GetterFn;
    _MethodFn?: reflection_types.MethodFn;
    CodegenComponentFactoryResolver: typeof component_factory_resolver.CodegenComponentFactoryResolver;
    _CodegenComponentFactoryResolver?: component_factory_resolver.CodegenComponentFactoryResolver;
    AppElement: typeof element.AppElement;
    _AppElement?: element.AppElement;
    AppView: typeof view.AppView;
    _AppView?: view.AppView<any>;
    DebugAppView: typeof view.DebugAppView;
    _DebugAppView?: view.DebugAppView<any>;
    NgModuleInjector: typeof ng_module_factory.NgModuleInjector;
    _NgModuleInjector?: ng_module_factory.NgModuleInjector<any>;
    registerModuleFactory: typeof ng_module_factory_loader.registerModuleFactory;
    ViewType: typeof view_type.ViewType;
    _ViewType?: view_type.ViewType;
    ViewMetadata: typeof metadata_view.ViewMetadata;
    _ViewMetadata?: metadata_view.ViewMetadata;
    DebugContext: typeof debug_context.DebugContext;
    _DebugContext?: debug_context.DebugContext;
    StaticNodeDebugInfo: typeof debug_context.StaticNodeDebugInfo;
    _StaticNodeDebugInfo?: debug_context.StaticNodeDebugInfo;
    devModeEqual: typeof change_detection_util.devModeEqual;
    UNINITIALIZED: typeof change_detection_util.UNINITIALIZED;
    ValueUnwrapper: typeof change_detection_util.ValueUnwrapper;
    _ValueUnwrapper?: change_detection_util.ValueUnwrapper;
    RenderDebugInfo: typeof api.RenderDebugInfo;
    _RenderDebugInfo?: api.RenderDebugInfo;
    TemplateRef_: typeof template_ref.TemplateRef_;
    _TemplateRef_?: template_ref.TemplateRef_<any>;
    ReflectionCapabilities: typeof reflection_capabilities.ReflectionCapabilities;
    _ReflectionCapabilities?: reflection_capabilities.ReflectionCapabilities;
    makeDecorator: typeof decorators.makeDecorator;
    DebugDomRootRenderer: typeof debug.DebugDomRootRenderer;
    _DebugDomRootRenderer?: debug.DebugDomRootRenderer;
    Console: typeof console.Console;
    _Console?: console.Console;
    reflector: typeof reflection.reflector;
    Reflector: typeof reflection.Reflector;
    _Reflector?: reflection.Reflector;
    NoOpAnimationPlayer: typeof NoOpAnimationPlayer_;
    _NoOpAnimationPlayer?: NoOpAnimationPlayer_;
    AnimationPlayer: typeof AnimationPlayer_;
    _AnimationPlayer?: AnimationPlayer_;
    AnimationSequencePlayer: typeof AnimationSequencePlayer_;
    _AnimationSequencePlayer?: AnimationSequencePlayer_;
    AnimationGroupPlayer: typeof AnimationGroupPlayer_;
    _AnimationGroupPlayer?: AnimationGroupPlayer_;
    AnimationKeyframe: typeof AnimationKeyframe_;
    _AnimationKeyframe?: AnimationKeyframe_;
    prepareFinalAnimationStyles: typeof animationUtils.prepareFinalAnimationStyles;
    balanceAnimationKeyframes: typeof animationUtils.balanceAnimationKeyframes;
    flattenStyles: typeof animationUtils.flattenStyles;
    clearStyles: typeof animationUtils.clearStyles;
    renderStyles: typeof animationUtils.renderStyles;
    collectAndResolveStyles: typeof animationUtils.collectAndResolveStyles;
    AnimationStyles: typeof AnimationStyles_;
    _AnimationStyles?: AnimationStyles_;
    ANY_STATE: typeof ANY_STATE_;
    DEFAULT_STATE: typeof DEFAULT_STATE_;
    EMPTY_STATE: typeof EMPTY_STATE_;
    FILL_STYLE_FLAG: typeof FILL_STYLE_FLAG_;
    _ComponentStillLoadingError?: ComponentStillLoadingError;
    ComponentStillLoadingError: typeof ComponentStillLoadingError;
    isPromise: typeof isPromise;
    AnimationTransition: typeof AnimationTransition;
    view_utils: typeof view_utils;
};
}
declare module '@angular/core/src/core_private_export' {
export * from '~@angular/core/src/core_private_export';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/metadata.d.ts
declare module '~@angular/core/src/animation/metadata' {
/**
 * @experimental Animation support is experimental.
 */
export const AUTO_STYLE: string;
/**
 * Metadata representing the entry of animations.
 * Instances of this class are provided via the animation DSL when the {@link trigger trigger
 * animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export class AnimationEntryMetadata {
    name: string;
    definitions: AnimationStateMetadata[];
    constructor(name: string, definitions: AnimationStateMetadata[]);
}
/**
 * @experimental Animation support is experimental.
 */
export abstract class AnimationStateMetadata {
}
/**
 * Metadata representing the entry of animations.
 * Instances of this class are provided via the animation DSL when the {@link state state animation
 * function} is called.
 *
 * @experimental Animation support is experimental.
 */
export class AnimationStateDeclarationMetadata extends AnimationStateMetadata {
    stateNameExpr: string;
    styles: AnimationStyleMetadata;
    constructor(stateNameExpr: string, styles: AnimationStyleMetadata);
}
/**
 * Metadata representing the entry of animations.
 * Instances of this class are provided via the animation DSL when the
 * {@link transition transition animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export class AnimationStateTransitionMetadata extends AnimationStateMetadata {
    stateChangeExpr: string;
    steps: AnimationMetadata;
    constructor(stateChangeExpr: string, steps: AnimationMetadata);
}
/**
 * @experimental Animation support is experimental.
 */
export abstract class AnimationMetadata {
}
/**
 * Metadata representing the entry of animations.
 * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes
 * animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export class AnimationKeyframesSequenceMetadata extends AnimationMetadata {
    steps: AnimationStyleMetadata[];
    constructor(steps: AnimationStyleMetadata[]);
}
/**
 * Metadata representing the entry of animations.
 * Instances of this class are provided via the animation DSL when the {@link style style animation
 * function} is called.
 *
 * @experimental Animation support is experimental.
 */
export class AnimationStyleMetadata extends AnimationMetadata {
    styles: Array<string | {
        [key: string]: string | number;
    }>;
    offset: number;
    constructor(styles: Array<string | {
        [key: string]: string | number;
    }>, offset?: number);
}
/**
 * Metadata representing the entry of animations.
 * Instances of this class are provided via the animation DSL when the {@link animate animate
 * animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export class AnimationAnimateMetadata extends AnimationMetadata {
    timings: string | number;
    styles: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata;
    constructor(timings: string | number, styles: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata);
}
/**
 * @experimental Animation support is experimental.
 */
export abstract class AnimationWithStepsMetadata extends AnimationMetadata {
    constructor();
    steps: AnimationMetadata[];
}
/**
 * Metadata representing the entry of animations.
 * Instances of this class are provided via the animation DSL when the {@link sequence sequence
 * animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export class AnimationSequenceMetadata extends AnimationWithStepsMetadata {
    private _steps;
    constructor(_steps: AnimationMetadata[]);
    steps: AnimationMetadata[];
}
/**
 * Metadata representing the entry of animations.
 * Instances of this class are provided via the animation DSL when the {@link group group animation
 * function} is called.
 *
 * @experimental Animation support is experimental.
 */
export class AnimationGroupMetadata extends AnimationWithStepsMetadata {
    private _steps;
    constructor(_steps: AnimationMetadata[]);
    steps: AnimationMetadata[];
}
/**
 * `animate` is an animation-specific function that is designed to be used inside of Angular2's
 * animation
 * DSL language. If this information is new, please navigate to the
 * {@link Component#animations-anchor component animations metadata
 * page} to gain a better understanding of how animations in Angular2 are used.
 *
 * `animate` specifies an animation step that will apply the provided `styles` data for a given
 * amount of
 * time based on the provided `timing` expression value. Calls to `animate` are expected to be
 * used within {@link sequence an animation sequence}, {@link group group}, or {@link transition
 * transition}.
 *
 * ### Usage
 *
 * The `animate` function accepts two input parameters: `timing` and `styles`:
 *
 * - `timing` is a string based value that can be a combination of a duration with optional
 * delay and easing values. The format for the expression breaks down to `duration delay easing`
 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
 * delay=100, easing=ease-out`.
 * If a numeric value is provided then that will be used as the `duration` value in millisecond
 * form.
 * - `styles` is the style input data which can either be a call to {@link style style} or {@link
 * keyframes keyframes}.
 * If left empty then the styles from the destination state will be collected and used (this is
 * useful when
 * describing an animation step that will complete an animation by {@link
 * transition#the-final-animate-call animating to the final state}).
 *
 * ```typescript
 * // various functions for specifying timing data
 * animate(500, style(...))
 * animate("1s", style(...))
 * animate("100ms 0.5s", style(...))
 * animate("5s ease", style(...))
 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
 *
 * // either style() of keyframes() can be used
 * animate(500, style({ background: "red" }))
 * animate(500, keyframes([
 *   style({ background: "blue" })),
 *   style({ background: "red" }))
 * ])
 * ```
 *
 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function animate(timing: string | number, styles?: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata): AnimationAnimateMetadata;
/**
 * `group` is an animation-specific function that is designed to be used inside of Angular2's
 * animation
 * DSL language. If this information is new, please navigate to the
 * {@link Component#animations-anchor component animations metadata
 * page} to gain a better understanding of how animations in Angular2 are used.
 *
 * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
 * are useful when a series of styles must be animated/closed off
 * at different statrting/ending times.
 *
 * The `group` function can either be used within a {@link sequence sequence} or a {@link transition
 * transition}
 * and it will only continue to the next instruction once all of the inner animation steps
 * have completed.
 *
 * ### Usage
 *
 * The `steps` data that is passed into the `group` animation function can either consist
 * of {@link style style} or {@link animate animate} function calls. Each call to `style()` or
 * `animate()`
 * within a group will be executed instantly (use {@link keyframes keyframes} or a
 * {@link animate#usage animate() with a delay value} to offset styles to be applied at a later
 * time).
 *
 * ```typescript
 * group([
 *   animate("1s", { background: "black" }))
 *   animate("2s", { color: "white" }))
 * ])
 * ```
 *
 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function group(steps: AnimationMetadata[]): AnimationGroupMetadata;
/**
 * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
 * animation
 * DSL language. If this information is new, please navigate to the
 * {@link Component#animations-anchor component animations metadata
 * page} to gain a better understanding of how animations in Angular2 are used.
 *
 * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
 * by default when an array is passed as animation data into {@link transition transition}.)
 *
 * The `sequence` function can either be used within a {@link group group} or a {@link transition
 * transition}
 * and it will only continue to the next instruction once each of the inner animation steps
 * have completed.
 *
 * To perform animation styling in parallel with other animation steps then
 * have a look at the {@link group group} animation function.
 *
 * ### Usage
 *
 * The `steps` data that is passed into the `sequence` animation function can either consist
 * of {@link style style} or {@link animate animate} function calls. A call to `style()` will apply
 * the
 * provided styling data immediately while a call to `animate()` will apply its styling
 * data over a given time depending on its timing data.
 *
 * ```typescript
 * sequence([
 *   style({ opacity: 0 })),
 *   animate("1s", { opacity: 1 }))
 * ])
 * ```
 *
 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function sequence(steps: AnimationMetadata[]): AnimationSequenceMetadata;
/**
 * `style` is an animation-specific function that is designed to be used inside of Angular2's
 * animation
 * DSL language. If this information is new, please navigate to the
 * {@link Component#animations-anchor component animations metadata
 * page} to gain a better understanding of how animations in Angular2 are used.
 *
 * `style` declares a key/value object containing CSS properties/styles that can then
 * be used for {@link state animation states}, within an {@link sequence animation sequence}, or as
 * styling data for both {@link animate animate} and {@link keyframes keyframes}.
 *
 * ### Usage
 *
 * `style` takes in a key/value string map as data and expects one or more CSS property/value
 * pairs to be defined.
 *
 * ```typescript
 * // string values are used for css properties
 * style({ background: "red", color: "blue" })
 *
 * // numerical (pixel) values are also supported
 * style({ width: 100, height: 0 })
 * ```
 *
 * #### Auto-styles (using `*`)
 *
 * When an asterix (`*`) character is used as a value then it will be detected from the element
 * being animated
 * and applied as animation data when the animation starts.
 *
 * This feature proves useful for a state depending on layout and/or environment factors; in such
 * cases
 * the styles are calculated just before the animation starts.
 *
 * ```typescript
 * // the steps below will animate from 0 to the
 * // actual height of the element
 * style({ height: 0 }),
 * animate("1s", style({ height: "*" }))
 * ```
 *
 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function style(tokens: string | {
    [key: string]: string | number;
} | Array<string | {
    [key: string]: string | number;
}>): AnimationStyleMetadata;
/**
 * `state` is an animation-specific function that is designed to be used inside of Angular2's
 * animation
 * DSL language. If this information is new, please navigate to the
 * {@link Component#animations-anchor component animations metadata
 * page} to gain a better understanding of how animations in Angular2 are used.
 *
 * `state` declares an animation state within the given trigger. When a state is
 * active within a component then its associated styles will persist on
 * the element that the trigger is attached to (even when the animation ends).
 *
 * To animate between states, have a look at the animation {@link transition transition}
 * DSL function. To register states to an animation trigger please have a look
 * at the {@link trigger trigger} function.
 *
 * #### The `void` state
 *
 * The `void` state value is a reserved word that angular uses to determine when the element is not
 * apart
 * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
 * associated element
 * is void).
 *
 * #### The `*` (default) state
 *
 * The `*` state (when styled) is a fallback state that will be used if
 * the state that is being animated is not declared within the trigger.
 *
 * ### Usage
 *
 * `state` will declare an animation state with its associated styles
 * within the given trigger.
 *
 * - `stateNameExpr` can be one or more state names separated by commas.
 * - `styles` refers to the {@link style styling data} that will be persisted on the element once
 * the state
 * has been reached.
 *
 * ```typescript
 * // "void" is a reserved name for a state and is used to represent
 * // the state in which an element is detached from from the application.
 * state("void", style({ height: 0 }))
 *
 * // user-defined states
 * state("closed", style({ height: 0 }))
 * state("open, visible", style({ height: "*" }))
 * ```
 *
 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function state(stateNameExpr: string, styles: AnimationStyleMetadata): AnimationStateDeclarationMetadata;
/**
 * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
 * animation
 * DSL language. If this information is new, please navigate to the
 * {@link Component#animations-anchor component animations metadata
 * page} to gain a better understanding of how animations in Angular2 are used.
 *
 * `keyframes` specifies a collection of {@link style style} entries each optionally characterized
 * by an `offset` value.
 *
 * ### Usage
 *
 * The `keyframes` animation function is designed to be used alongside the {@link animate animate}
 * animation function. Instead of applying animations from where they are
 * currently to their destination, keyframes can describe how each style entry is applied
 * and at what point within the animation arc (much like CSS Keyframe Animations do).
 *
 * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
 * what percentage of the animate time the styles will be applied.
 *
 * ```typescript
 * // the provided offset values describe when each backgroundColor value is applied.
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red", offset: 0 }),
 *   style({ backgroundColor: "blue", offset: 0.2 }),
 *   style({ backgroundColor: "orange", offset: 0.3 }),
 *   style({ backgroundColor: "black", offset: 1 })
 * ]))
 * ```
 *
 * Alternatively, if there are no `offset` values used within the style entries then the offsets
 * will
 * be calculated automatically.
 *
 * ```typescript
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red" }) // offset = 0
 *   style({ backgroundColor: "blue" }) // offset = 0.33
 *   style({ backgroundColor: "orange" }) // offset = 0.66
 *   style({ backgroundColor: "black" }) // offset = 1
 * ]))
 * ```
 *
 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSequenceMetadata;
/**
 * `transition` is an animation-specific function that is designed to be used inside of Angular2's
 * animation
 * DSL language. If this information is new, please navigate to the
 * {@link Component#animations-anchor component animations metadata
 * page} to gain a better understanding of how animations in Angular2 are used.
 *
 * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
 * provided
 * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
 * which consists
 * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
 *
 * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
 * to animate to
 * a state value and persist its styles then one or more {@link state animation states} is expected
 * to be defined.
 *
 * ### Usage
 *
 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
 * what the
 * previous state is and what the current state has become. In other words, if a transition is
 * defined that
 * matches the old/current state criteria then the associated animation will be triggered.
 *
 * ```typescript
 * // all transition/state changes are defined within an animation trigger
 * trigger("myAnimationTrigger", [
 *   // if a state is defined then its styles will be persisted when the
 *   // animation has fully completed itself
 *   state("on", style({ background: "green" })),
 *   state("off", style({ background: "grey" })),
 *
 *   // a transition animation that will be kicked off when the state value
 *   // bound to "myAnimationTrigger" changes from "on" to "off"
 *   transition("on => off", animate(500)),
 *
 *   // it is also possible to do run the same animation for both directions
 *   transition("on <=> off", animate(500)),
 *
 *   // or to define multiple states pairs separated by commas
 *   transition("on => off, off => void", animate(500)),
 *
 *   // this is a catch-all state change for when an element is inserted into
 *   // the page and the destination state is unknown
 *   transition("void => *", [
 *     style({ opacity: 0 }),
 *     animate(500)
 *   ]),
 *
 *   // this will capture a state change between any states
 *   transition("* => *", animate("1s 0s")),
 * ])
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger`
 * animation trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * #### The final `animate` call
 *
 * If the final step within the transition steps is a call to `animate()` that **only**
 * uses a timing value with **no style data** then it will be automatically used as the final
 * animation
 * arc for the element to animate itself to the final state. This involves an automatic mix of
 * adding/removing CSS styles so that the element will be in the exact state it should be for the
 * applied state to be presented correctly.
 *
 * ```
 * // start off by hiding the element, but make sure that it animates properly to whatever state
 * // is currently active for "myAnimationTrigger"
 * transition("void => *", [
 *   style({ opacity: 0 }),
 *   animate(500)
 * ])
 * ```
 *
 * ### Transition Aliases (`:enter` and `:leave`)
 *
 * Given that enter (insertion) and leave (removal) animations are so common,
 * the `transition` function accepts both `:enter` and `:leave` values which
 * are aliases for the `void => *` and `* => void` state changes.
 *
 * ```
 * transition(":enter", [
 *   style({ opacity: 0 }),
 *   animate(500, style({ opacity: 1 }))
 * ])
 * transition(":leave", [
 *   animate(500, style({ opacity: 0 }))
 * ])
 * ```
 *
 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function transition(stateChangeExpr: string, steps: AnimationMetadata | AnimationMetadata[]): AnimationStateTransitionMetadata;
/**
 * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
 * animation
 * DSL language. If this information is new, please navigate to the
 * {@link Component#animations-anchor component animations metadata
 * page} to gain a better understanding of how animations in Angular2 are used.
 *
 * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link
 * transition transition}
 * entries that will be evaluated when the expression bound to the trigger changes.
 *
 * Triggers are registered within the component annotation data under the
 * {@link Component#animations-anchor animations section}. An animation trigger can
 * be placed on an element within a template by referencing the name of the
 * trigger followed by the expression value that the trigger is bound to
 * (in the form of `[@triggerName]="expression"`.
 *
 * ### Usage
 *
 * `trigger` will create an animation trigger reference based on the provided `name` value.
 * The provided `animation` value is expected to be an array consisting of {@link state state} and
 * {@link transition transition}
 * declarations.
 *
 * ```typescript
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *       state(...),
 *       state(...),
 *       transition(...),
 *       transition(...)
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "something";
 * }
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger`
 * animation trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function trigger(name: string, animation: AnimationMetadata[]): AnimationEntryMetadata;
}
declare module '@angular/core/src/animation/metadata' {
export * from '~@angular/core/src/animation/metadata';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_transition_event.d.ts
declare module '~@angular/core/src/animation/animation_transition_event' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An instance of this class is returned as an event parameter when an animation
 * callback is captured for an animation either during the start or done phase.
 *
 * ```typescript
 * @Component({
 *   host: {
 *     '[@myAnimationTrigger]': 'someExpression',
 *     '(@myAnimationTrigger.start)': 'captureStartEvent($event)',
 *     '(@myAnimationTrigger.done)': 'captureDoneEvent($event)',
 *   },
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *        // ...
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   someExpression: any = false;
 *   captureStartEvent(event: AnimationTransitionEvent) {
 *     // the toState, fromState and totalTime data is accessible from the event variable
 *   }
 *
 *   captureDoneEvent(event: AnimationTransitionEvent) {
 *     // the toState, fromState and totalTime data is accessible from the event variable
 *   }
 * }
 * ```
 *
 * @experimental Animation support is experimental.
 */
export class AnimationTransitionEvent {
    fromState: string;
    toState: string;
    totalTime: number;
    phaseName: string;
    constructor({fromState, toState, totalTime, phaseName}: {
        fromState: string;
        toState: string;
        totalTime: number;
        phaseName: string;
    });
}
}
declare module '@angular/core/src/animation/animation_transition_event' {
export * from '~@angular/core/src/animation/animation_transition_event';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_player.d.ts
declare module '~@angular/core/src/animation/animation_player' {
/**
 * @experimental Animation support is experimental.
 */
export abstract class AnimationPlayer {
    abstract onDone(fn: () => void): void;
    abstract onStart(fn: () => void): void;
    abstract init(): void;
    abstract hasStarted(): boolean;
    abstract play(): void;
    abstract pause(): void;
    abstract restart(): void;
    abstract finish(): void;
    abstract destroy(): void;
    abstract reset(): void;
    abstract setPosition(p: any): void;
    abstract getPosition(): number;
    parentPlayer: AnimationPlayer;
}
export class NoOpAnimationPlayer implements AnimationPlayer {
    private _onDoneFns;
    private _onStartFns;
    private _started;
    parentPlayer: AnimationPlayer;
    constructor();
    onStart(fn: () => void): void;
    onDone(fn: () => void): void;
    hasStarted(): boolean;
    init(): void;
    play(): void;
    pause(): void;
    restart(): void;
    finish(): void;
    destroy(): void;
    reset(): void;
    setPosition(p: any): void;
    getPosition(): number;
}
}
declare module '@angular/core/src/animation/animation_player' {
export * from '~@angular/core/src/animation/animation_player';
}

// Generated by typings
// Source: node_modules/@angular/core/src/security.d.ts
declare module '~@angular/core/src/security' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
 * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
 * handled.
 *
 * See DomSanitizer for more details on security in Angular applications.
 *
 * @stable
 */
export enum SecurityContext {
    NONE = 0,
    HTML = 1,
    STYLE = 2,
    SCRIPT = 3,
    URL = 4,
    RESOURCE_URL = 5,
}
/**
 * Sanitizer is used by the views to sanitize potentially dangerous values.
 *
 * @stable
 */
export abstract class Sanitizer {
    abstract sanitize(context: SecurityContext, value: string): string;
}
}
declare module '@angular/core/src/security' {
export * from '~@angular/core/src/security';
}

// Generated by typings
// Source: node_modules/@angular/core/src/core.d.ts
declare module '~@angular/core/src/core' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point from which you should import all public core APIs.
 */
export * from '~@angular/core/src/metadata';
export * from '~@angular/core/src/util';
export * from '~@angular/core/src/di';
export { createPlatform, assertPlatform, destroyPlatform, getPlatform, PlatformRef, ApplicationRef, enableProdMode, isDevMode, createPlatformFactory } from '~@angular/core/src/application_ref';
export { APP_ID, PACKAGE_ROOT_URL, PLATFORM_INITIALIZER, APP_BOOTSTRAP_LISTENER } from '~@angular/core/src/application_tokens';
export { APP_INITIALIZER, ApplicationInitStatus } from '~@angular/core/src/application_init';
export * from '~@angular/core/src/zone';
export * from '~@angular/core/src/render';
export * from '~@angular/core/src/linker';
export { DebugElement, DebugNode, asNativeElements, getDebugNode } from '~@angular/core/src/debug/debug_node';
export { GetTestability, Testability, TestabilityRegistry, setTestabilityGetter } from '~@angular/core/src/testability/testability';
export * from '~@angular/core/src/change_detection';
export * from '~@angular/core/src/platform_core_providers';
export { TRANSLATIONS, TRANSLATIONS_FORMAT, LOCALE_ID } from '~@angular/core/src/i18n/tokens';
export { ApplicationModule } from '~@angular/core/src/application_module';
export { wtfCreateScope, wtfLeave, wtfStartTimeRange, wtfEndTimeRange, WtfScopeFn } from '~@angular/core/src/profile/profile';
export { Type } from '~@angular/core/src/type';
export { EventEmitter } from '~@angular/core/src/facade/async';
export { ErrorHandler } from '~@angular/core/src/error_handler';
export * from '~@angular/core/src/core_private_export';
export * from '~@angular/core/src/animation/metadata';
export { AnimationTransitionEvent } from '~@angular/core/src/animation/animation_transition_event';
export { AnimationPlayer } from '~@angular/core/src/animation/animation_player';
export { Sanitizer, SecurityContext } from '~@angular/core/src/security';
}
declare module '@angular/core/src/core' {
export * from '~@angular/core/src/core';
}

// Generated by typings
// Source: node_modules/@angular/core/index.d.ts
declare module '~@angular/core/index' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the core package.
 */
export * from '~@angular/core/src/core';
}
declare module '@angular/core/index' {
export * from '~@angular/core/index';
}
declare module '@angular/core' {
export * from '~@angular/core/index';
}
